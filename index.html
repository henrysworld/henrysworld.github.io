<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="守住自己那颗宁静的心！">
<meta property="og:type" content="website">
<meta property="og:title" content="宁静的世界">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="宁静的世界">
<meta property="og:description" content="守住自己那颗宁静的心！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宁静的世界">
<meta name="twitter:description" content="守住自己那颗宁静的心！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>宁静的世界</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">宁静的世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">致我逝去的青春</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/26/kubernetes-scheduler /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/12/26/kubernetes-scheduler /" itemprop="url">Kubernetes调度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-12-26T14:53:58+08:00">
                2022-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/Scheduler/" itemprop="url" rel="index">
                    <span itemprop="name">Scheduler</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kubernetes调度"><a href="#Kubernetes调度" class="headerlink" title="Kubernetes调度"></a>Kubernetes调度</h1><h2 id="一、调度系统集群模式"><a href="#一、调度系统集群模式" class="headerlink" title="一、调度系统集群模式"></a>一、调度系统集群模式</h2><p>Kubernetes调度系统本身的集群模式是主从。由Master节点负责调度，将任务调度分配到Node节点中。</p>
<h2 id="二、在集群模式下，调度系统本身如何调度资源，例如如果要调度任务-A，那么应该是在调度系统进群的哪个节点上调度"><a href="#二、在集群模式下，调度系统本身如何调度资源，例如如果要调度任务-A，那么应该是在调度系统进群的哪个节点上调度" class="headerlink" title="二、在集群模式下，调度系统本身如何调度资源，例如如果要调度任务 A，那么应该是在调度系统进群的哪个节点上调度"></a>二、在集群模式下，调度系统本身如何调度资源，例如如果要调度任务 A，那么应该是在调度系统进群的哪个节点上调度</h2><p>Kubernetes的调度模式如下：</p>
<p>首先调度器会寻找nodeName为空的Pod进行作业调度，调度流程分为两部。<br>第一步Predicate：过滤不符合条件的节点</p>
<p>第二部Priority：优先级打分排序，选择优先级最高的节点。</p>
<h2 id="三、任务分类"><a href="#三、任务分类" class="headerlink" title="三、任务分类"></a>三、任务分类</h2><p>Kubernetes支持 LRS（Long Running Service）和 Batch Jobs 两种作业形态，对它们进行“分别管理”和“混合调度”。这里针对于任务分类，我们主要说一下Job和CronJob这两个对象。</p>
<ol>
<li>首先我先介绍一下Job对象中负责并行控制的两个参数：<ul>
<li><strong>spec.completions</strong>：控制任务完成的数量。它定义的是 Job 至少要完成的 Pod 数目，即 Job 的最小完成数。</li>
<li><strong>spec.parallelism</strong>：控制任务并行数。它定义的是一个 Job 在任意时间最多可以启动多少个 Pod 同时运行</li>
</ul>
</li>
<li>CronJob 他是一个专门用来管理 Job 对象的控制器。只不过，它创建和删除 Job 的依据，是 schedule 字段定义的、一个标准的Unix Cron格式的表达式。</li>
</ol>
<p>所以对于我们对于任务的分类可以使用如下方式来实现：</p>
<ul>
<li>重复任务：可以将completions设置为重复完成的数量，parallelism根据需求设定</li>
<li>定时任务：可以使用cronJob来实现定时任务。</li>
<li>一次性任务：可以将completions设置为1。</li>
<li>实时任务：可以使用job来实现。</li>
</ul>
<h2 id="四、任务管理"><a href="#四、任务管理" class="headerlink" title="四、任务管理"></a>四、任务管理</h2><p>Kubernetes是通过apiserver来查询任务的运行情况。当任务的STATUS字段会记录用户任务执行的情况。</p>
<p>任务日志可以输出到stdout和stderr中然后通过在宿主机上部署 logging-agent 的方式来集中处理日志。</p>
<p>Kubernetes整个项目是声明式API，他只规定他的期望的目的。然后剩下的交给系统来处理。直到达到期望值。一个 Kubernetes 的控制器，实际上就是一个“死循环”，它不断地获取“实际状态”，然后与“期望状态”作对比，并以此为依据决定下一步的操作。</p>
<p>因此他允许删除任务。删除时，将任务，没有调度的任务直接从队列里丢弃。允许修改任务配置。修改调度配置以后会按照新的调度配置重新执行一遍。当删除任务时，任务先接收term信号， 再接收kill信号。</p>
<h2 id="五、任务编排"><a href="#五、任务编排" class="headerlink" title="五、任务编排"></a>五、任务编排</h2><p>Kubernetes的核心功能就是任务编排。kube-controller-manager这个组件，就是一系列控制器的集合。每一个控制器，都以独有的方式负责某种编排功能。这里的控制器，都遵循 Kubernetes 项目中的一个通用编排模式，即：控制循环（control loop）</p>
<p>比如，现在有一种待编排的对象 X，它有一个对应的控制器。那么，我就可以用一段 Go 语言风格的伪代码，为你描述这个控制循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  实际状态 := 获取集群中对象X的实际状态（Actual State）</span><br><span class="line">  期望状态 := 获取集群中对象X的期望状态（Desired State）</span><br><span class="line">  <span class="keyword">if</span> 实际状态 == 期望状态&#123;</span><br><span class="line">    什么都不做</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行编排动作，将实际状态调整为期望状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例：<br>以Deployment 对象中 Replicas 字段的值为例。很明显，这些信息往往都保存在 Etcd 中。</p>
<p>接下来，以 Deployment 为例，我和你简单描述一下它对控制器模型的实现：</p>
<ol>
<li>Deployment 控制器从 Etcd 中获取到所有携带了“app: nginx”标签的 Pod，然后统计它们的数量，这就是实际状态；</li>
<li>Deployment 对象的 Replicas 字段的值就是期望状态；</li>
<li>Deployment 控制器将两个状态做比较，然后根据比较结果，确定是创建 Pod，还是删除已有的 Pod；</li>
</ol>
<p>可以看到，一个 Kubernetes 对象的主要编排逻辑，实际上是在第三步的“对比”阶段完成的。这个操作，通常被叫作调谐（Reconcile）。这个调谐的过程，则被称作“Reconcile Loop”（调谐循环）或者“Sync Loop”（同步循环）。</p>
<p>Deployment控制器，控制ReplicaSet。ReplicaSet支持Pod的“水平扩展 / 收缩”和“滚动更新”</p>
<p>Deployment 同样通过“控制器模式”，来操作 ReplicaSet 的个数和属性，进而实现“水平扩展 / 收缩”和“滚动更新”这两个编排动作。</p>
<p>比如，把replicas这个值从 3 改成 4，那么 Deployment 所对应的 ReplicaSet，就会根据修改后的值自动创建一个新的 Pod。这就是“水平扩展”了；“水平收缩”则反之。</p>
<h2 id="六、任务注册与任务发现"><a href="#六、任务注册与任务发现" class="headerlink" title="六、任务注册与任务发现"></a>六、任务注册与任务发现</h2><p>Kubernetes有后台管理界面可以注册任务。<br>以Deployment为例，注册时填写的字段有：应用名称、容器镜像、pod的数量、定义的Service。还有一些高级选项如下图所示。</p>
<p><img src="https://blob.hixforever.com/20221223175901.png" alt="https://blob.hixforever.com/20221223175901.png"></p>
<p>Kubernetes还可以以编程的形式创建任务。可以使用<em><a href="https://github.com/kubernetes/client-go" target="_blank" rel="noopener">client-go</a>来进行接入。</em></p>
<h2 id="七、任务形态"><a href="#七、任务形态" class="headerlink" title="七、任务形态"></a>七、任务形态</h2><p>Kubernetes可以通过grpc和http两种形式创建任务。</p>
<ol>
<li>使用管理控制台来创建任务时调用的是https处理任务。</li>
<li>使用命令行在创建任务时是调用的是grpc处理任务。</li>
</ol>
<h2 id="八、调度模型"><a href="#八、调度模型" class="headerlink" title="八、调度模型"></a>八、调度模型</h2><p>kube-scheduler监听kube-apiserver，查询还未分配Node的Pod（即NodeName为空的Pod）。</p>
<p>kubernetes的线程模型是goroutine模型，goroutine调度器的流程本质上是一个生产-消费的流程。</p>
<p>它的调度模型与算法也是不断优化演变的，从最初的 G-M 模型、到 G-M-P 模型，从不支持抢占，到支持协作式抢占，再到支持基于信号的异步抢占。下面简单的介绍一下GMP模型:</p>
<p>G：我们可以看做是goroutine</p>
<p>P：逻辑处理器，他上面最重要的三个结构是runNext、local run queue、global run queue。</p>
<p>M：系统线程（真正处理任务的CPU）</p>
<p>首先G我们可以看做生产者，当一个goroutine被创建时，会包装成一个G，</p>
<ol>
<li>此时生成的G会先看一下P的runnext上有没有G。</li>
<li>如果没有的话，刚创建的G则直接放在runnext上，</li>
<li>如果runNext上有G，看一下P上的local run queue有没有满<ol>
<li>如果没有满，则将runnext上的G放到local run queue（本地队列中）</li>
<li>如果满了，则将runnext上的G+local run queue中一半的G拿出来组成一个链表放到global run queue（全局队列）中。</li>
</ol>
</li>
</ol>
<p>M我们可以看做消费者，</p>
<ol>
<li>首先runtime.schedle检测schedtick%61==0？</li>
<li>如果schedtick%61==0，则直接从全局队列里获取队里第一个G执行。</li>
<li>schedtick%61≠0，先看P中runnext是否有值</li>
<li>如果runnext中有值，M直接拿runnext中的G执行。</li>
<li>如果runnext中没有值，先去看local run queue中是否有G，</li>
<li>local run queue有G则获取本地队列里的第一个G放到M上执行</li>
<li>local run queue没有G，则去看global run queue中是否有G</li>
<li>global run queue有G，则从global run queue中取（全局队列g总数 / gomaxprocs）+ 1个，但是不能超过128个G。将从全局队列中拿出来的G的第一个放到M上执行，剩下的放入到本地队列中。</li>
<li>global run queue没有G，则去看其他P中是否有G，如果有的话，从其他P的local run queue中的队头开始，偷一半。取偷过来的最后一个放到M上执行，剩下的放入当前P的本地队列中。</li>
</ol>
<p>下面我们在看一下goroutine 调度器是如何进行抢占式调度的。Go 程序启动时，运行时会去启动一个名为 sysmon 的 M（一般称为监控线程），这个 M 的特殊之处在于它不需要绑定 P 就可以运行（以 g0 这个 G 的形式）</p>
<p>sysmon 每 20us~10ms 启动一次，sysmon 主要完成了这些工作：</p>
<ol>
<li>释放闲置超过 5 分钟的 span 内存；</li>
<li>如果超过 2 分钟没有垃圾回收，强制执行；</li>
<li>将长时间未处理的 netpoll 结果添加到任务队列；</li>
<li>向长时间运行的 G 任务发出抢占调度；</li>
<li>收回因 syscall 长时间阻塞的 P；</li>
</ol>
<p>如果一个 G 任务运行 10ms，sysmon 就会认为它的运行时间太久而发出抢占式调度的请求。一旦 G 的抢占标志位被设为 true，那么等到这个 G 下一次调用函数或方法时，运行时就可以将 G 抢占并移出运行状态，放入队列中，等待下一次被调度。</p>
<h2 id="九、调度策略"><a href="#九、调度策略" class="headerlink" title="九、调度策略"></a>九、调度策略</h2><p>在第二大部分时，有介绍到对于Kubernetes的调度分为两个部分，第一部分Predicates，先对所有节点进行按照一定的策略进行过滤，第二部分Priority，对第一部分过滤出来的结果按照一定的策略进行打分，选择打分最高的节点进行调度。下面我来分别介绍一下这两部分的调度策略。</p>
<ol>
<li>Predicates中的调度策略有很多种，还可以自己编写自己的调度策略，这里我就简单介绍下面几种调度策略：<ul>
<li>PodFitsHostPorts：检查是否有Host Ports冲突</li>
<li>PodFitsPorts：和PodFitsHostPorts相同</li>
<li>PodFitsResources：检查Node的资源是否充足，包括允许的Pod数量、CPU、内存、GPU个数以及其他的OpaqueIntResources。</li>
<li>HostName：检查pod.Spec.NodeName是否与候选节点一致。</li>
<li>MatchNodeSelector：检查候选节点的pod.Spec.NodeSelector是否匹配</li>
<li>NoVolumeZoneConflict：检查volume zone是否冲突</li>
<li>MatchinterPodAffinity：检查是否匹配Pod的亲和性要求</li>
<li>NoDiskConflict：检查是否存在Volume冲突，仅限于GCE PD、AWS EBS、Ceph RBD以及ISCSI。</li>
<li>PodToleratesNodeTaints：检查Pod是否容忍Node Taints。</li>
<li>CheckNodeMemoryPressure：检查Pod是否可以调度到MemoryPressure的节点上。</li>
<li>CheckNodeDiskPressure：检查Pod是否可以调度到DiskPressure的节点上。</li>
<li>NoVolumeNodeConflict：检查节点是否满足Pod所引用的Volume的条件。</li>
</ul>
</li>
<li>Priority中的调度策略有很多种，还可以自己编写自己的调度策略，这里我就简单介绍下面几种调度策略：<ul>
<li>SelectorSpreadPriority：优先减少节点上属于同一个Service或Replication Controller的Pod数量</li>
<li>InterPodAffinityPriority：优先将Pod调度到相同的拓扑上（如同一个节点、Rack、Zone等）</li>
<li>LeastRequestedPriority：优先调度到请求资源少的节点上。</li>
<li>BalancedResourceAllocation：优先平衡各节点的资源使用。</li>
<li>NodePreferAvoidPodsPriority：alpha.kubernetes.io/preferAvoidPods 字段判断，权重为10000，避免其他优先级策略的影响。</li>
<li>NodeAffinityPriority：优先调度到匹配NodeAffinity的节点上。</li>
<li>TaintTolerationPriority：优先调度到匹配TaintToleration的节点上。</li>
<li>ServiceSpreadingPriority：尽量将同一个service的Pod分布到不同节点上，已经被SelectorSpreadPriority替代（默认未使用）</li>
<li>EqualPriority：将所有节点的优先级设置为1（默认未使用）</li>
<li>ImageLocalityPriority：尽量将使用大镜像的容器调度到已经下拉了该镜像的节点上（默认未使用）</li>
<li>MostRequestedPriority：尽量调度到已经使用过的Node上，特别适用于cluster-autoscaler（默认未使用）</li>
</ul>
</li>
</ol>
<p>Kubernetes是允许用户通过调度框架（Scheduling Framework）来自定义调度器。Scheduling Framework为我们定义了一些扩展点，用户能够实现扩展点定义的接口来定义本身的调度逻辑，并将扩展注册到扩展点上，调度器在执行调度流程时，会检查扩展plugin，如果有的话扩展plugin的话，则处理扩展plugin。</p>
<p>Scheduler 扩展点：</p>
<p>调度行为发生在一系列阶段中，这些阶段是通过以下扩展点公开的：</p>
<ul>
<li>QueueSort：这些插件对调度队列中的悬决的 Pod 排序。 一次只能启用一个队列排序插件。</li>
<li>PreFilter：这些插件用于在过滤之前预处理或检查 Pod 或集群的信息。 它们可以将 Pod 标记为不可调度。</li>
<li>Filter：这些插件相当于调度策略中的断言（Predicates），用于过滤不能运行 Pod 的节点。 过滤器的调用顺序是可配置的。 如果没有一个节点通过所有过滤器的筛选，Pod 将会被标记为不可调度。</li>
<li>PreScore：这是一个信息扩展点，可用于预打分工作。</li>
<li>Score：这些插件给通过筛选阶段的节点打分。调度器会选择得分最高的节点。</li>
<li>Reserve：这是一个信息扩展点，当资源已经预留给 Pod 时，会通知插件。 这些插件还实现了 Unreserve 接口，在 Reserve 期间或之后出现故障时调用。</li>
<li>Permit：这些插件可以阻止或延迟 Pod 绑定。</li>
<li>PreBind：这些插件在 Pod 绑定节点之前执行。</li>
<li>Bind：这个插件将 Pod 与节点绑定。绑定插件是按顺序调用的，只要有一个插件完成了绑定，其余插件都会跳过。绑定插件至少需要一个。</li>
<li>PostBind：这是一个信息扩展点，在 Pod 绑定了节点之后调用。</li>
</ul>
<h2 id="十、监控与告警"><a href="#十、监控与告警" class="headerlink" title="十、监控与告警"></a>十、监控与告警</h2><p>Kubernetes 项目的监控体系是以 Prometheus 项目为核心的一套统一的方案。下面是Prometheus官网的架构图。</p>
<p><img src="https://blob.hixforever.com/20221224094332.png" alt="https://blob.hixforever.com/20221224094332.png"></p>
<p>可以看到，Prometheus 项目工作的核心，是使用 Pull （抓取）的方式去搜集被监控对象的 Metrics 数据（监控指标数据），然后，再把这些数据保存在一个 TSDB （时间序列数据库，比如 OpenTSDB、InfluxDB 等）当中，以便后续可以按照时间进行检索。</p>
<p>有了这套核心监控机制， Prometheus 剩下的组件就是用来配合这套机制的运行。比如 Pushgateway，可以允许被监控对象以 Push 的方式向 Prometheus 推送 Metrics 数据。而 Alertmanager，则可以根据 Metrics 信息灵活地设置报警。当然， Prometheus 最受用户欢迎的功能，还是通过 Grafana 对外暴露出的、可以灵活配置的监控数据可视化界面。</p>
<p>Kubernetes中Prometheus 拉取的Metrics 数据的来源大致分为三种：</p>
<ol>
<li><strong>宿主机的监控数据</strong>。这部分数据的提供，需要借助一个由 Prometheus 维护的Node Exporter 工具。一般来说，Node Exporter 会以 DaemonSet 的方式运行在宿主机上。其实，所谓的 Exporter，就是代替被监控对象来对 Prometheus 暴露出可以被“抓取”的 Metrics 信息的一个辅助进程。</li>
<li><strong>Kubernetes 的 API Server、kubelet 等组件的 /metrics API</strong>。除了常规的 CPU、内存的信息外，这部分信息还主要包括了各个组件的核心监控指标。比如，对于 API Server 来说，它就会在 /metrics API 里，暴露出各个 Controller 的工作队列（Work Queue）的长度、请求的 QPS 和延迟数据等等。这些信息，是检查 Kubernetes 本身工作情况的主要依据。</li>
<li><strong>Kubernetes 相关的监控数据</strong>。这部分数据，一般叫作 Kubernetes 核心监控数据（core metrics）。这其中包括了 Pod、Node、容器、Service 等主要 Kubernetes 核心概念的 Metrics。</li>
</ol>
<h2 id="十一、认证和权限"><a href="#十一、认证和权限" class="headerlink" title="十一、认证和权限"></a>十一、认证和权限</h2><p>Kubernetes使用Namespace来实现资源的隔离。</p>
<p>用户使用 kubectl、客户端库或构造 REST 请求来访问 Kubernetes API。 Kubernetes 服务账户（ServiceAccount）可以被鉴权访问 API。 当请求到达 API 时，它会经历多个阶段，如下图所示：</p>
<p><img src="https://blob.hixforever.com/20221223203432.png" alt="https://blob.hixforever.com/20221223203432.png"></p>
<p>具体的权限控制流程如下：</p>
<ul>
<li>用户携带令牌或者证书给Kubernetes的api-server发送请求要求查询修改集群资源</li>
<li>Kubernetes开始认证。认证通过</li>
<li>Kubernetes查询用户的授权（在 Kubernetes 项目中，负责完成授权（Authorization）工作的机制，就是 RBAC）</li>
<li>用户执行操作。过程中的一些操作（cpu、内存、硬盘、网络等….），利用准入控制来判断是否可以允许操作</li>
</ul>
<p>对于API Server来说，可以使用<strong><strong>Webhook 模式</strong></strong>来实现自己的认证、鉴权和准入控制功能。也可以集成第三方的认证、鉴权和准入控制。</p>
<h2 id="十二、数据存储"><a href="#十二、数据存储" class="headerlink" title="十二、数据存储"></a>十二、数据存储</h2><p>Kubernetes是使用etcd来进行数据存储的。</p>
<p>在 Kubernetes 项目中，一个 API 对象在 Etcd 里的完整资源路径，是由：Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。通过这样的结构，整个 Kubernetes 里的所有 API 对象，实际上就可以用如下的树形结构表示出来：</p>
<p><img src="https://blob.hixforever.com/20221226143254.png" alt="https://blob.hixforever.com/20221226143254.png"></p>
<p>我们来看一下Kubernetes 是如何对 Resource、Group 和 Version 进行解析，从而在 Kubernetes 项目里找到 CronJob 对象的定义。</p>
<ol>
<li>Kubernetes 会匹配 API 对象的组。</li>
<li>Kubernetes 会进一步匹配到 API 对象的版本号。</li>
<li>Kubernetes 会匹配 API 对象的资源类型。</li>
</ol>
<p>在前面匹配到正确的版本之后，Kubernetes 就知道，我要创建的原来是一个 /apis/batch/v2alpha1 下的 CronJob 对象。</p>
<h2 id="十三、-以一个简单的任务为例子，解释整个系统的运作过程"><a href="#十三、-以一个简单的任务为例子，解释整个系统的运作过程" class="headerlink" title="十三、 以一个简单的任务为例子，解释整个系统的运作过程"></a>十三、 以一个简单的任务为例子，解释整个系统的运作过程</h2><p>以Kubernetes使用默认调度器，为一个新创建出来的Pod，寻找一个最合适的节点（Node）为例。</p>
<p>默认调度器会首先调用一组叫作 Predicate 的调度算法，来检查每个 Node。然后，再调用一组叫作 Priority 的调度算法，来给上一步得到的结果里的每个 Node 打分。最终的调度结果，就是得分最高的那个 Node。然后调度器会在Pod的spec.nodeName 字段填上调度结果的节点名字。到这里调度器对一个 Pod 的调度就完成了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/01/k8s-rook-ceph-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/01/k8s-rook-ceph-install/" itemprop="url">搭建Rook Ceph存储集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-01T17:39:41+08:00">
                2022-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/Rook/" itemprop="url" rel="index">
                    <span itemprop="name">Rook</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/Rook/Ceph/" itemprop="url" rel="index">
                    <span itemprop="name">Ceph</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搭建rook-ceph存储集群"><a href="#搭建rook-ceph存储集群" class="headerlink" title="搭建rook ceph存储集群"></a><strong>搭建rook ceph存储集群</strong></h1><h2 id="一、安装Rook集群"><a href="#一、安装Rook集群" class="headerlink" title="一、安装Rook集群"></a><strong>一、安装Rook集群</strong></h2><blockquote>
<p><a href="https://www.rook.io/docs/rook/v1.8/quickstart.html" target="_blank" rel="noopener">https://www.rook.io/docs/rook/v1.8/quickstart.html</a></p>
</blockquote>
<ol>
<li><p>下载代码</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --single-branch --branch v1.8.3 https://github.com/rook/rook.git</span><br><span class="line"><span class="built_in">cd</span> rook/deploy/examples</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>修改operator.yaml文件（主要是修改镜像文件下载地址，无法直接在国内网络环境下从k8s.gcr.io下载镜像，最好使用翻墙工具在自己电脑上下好镜像然后在生产服务器上直接使用）。如下图所示：</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ROOK_CSI_CEPH_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/cephcsi@sha256:19634b6ef9fc6df2902cf6ff0b3dbccc56a6663d0cbfd065da44ecd2f955d848"</span></span><br><span class="line"><span class="attr">ROOK_CSI_REGISTRAR_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/csi-node-driver-registrar@sha256:01b341312ea19cefc29f46fa0dd54255530b9039dd80834f50d582ecd93cc3ca"</span></span><br><span class="line"><span class="attr">ROOK_CSI_RESIZER_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/csi-resizer@sha256:d2d2e429a0a87190ee73462698a02a08e555055246ad87ad979b464b999fedae"</span></span><br><span class="line"><span class="attr">ROOK_CSI_PROVISIONER_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/csi-provisioner@sha256:bbae7cde811054f6a51060ba7a42d8bf2469b8c574abb50fec8b46c13e32541e"</span></span><br><span class="line"><span class="attr">ROOK_CSI_SNAPSHOTTER_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/csi-snapshotter@sha256:551b9692943f915b5ee4b7274e3a918692a6175bb028f1f0236a38596c46cbe0"</span></span><br><span class="line"><span class="attr">ROOK_CSI_ATTACHER_IMAGE:</span> <span class="string">"testharbor.zuoyejia.com/k8s_image/csi-attacher@sha256:221c1c6930fb1cb93b57762a74ccb59194c4c74a63c0fd49309d1158d4f8c72c"</span></span><br></pre></td></tr></table></figure>
<p> <img src="https://blob.hixforever.com/image-20220129150501500.png" alt=""></p>
</li>
<li><p>修改cluster.yaml文件（主要修改镜像地址、mon数量、mgr数量、dashboard的ssl）</p>
<ul>
<li>mgr数量：Ceph集群需要可用，所以最好配置为2（这里有个深坑这里的高可用是主备模式，在配置dashboard的时候需要注意）</li>
<li><p>dashboard的ssl：修改这个是因为我们使用ingress的方式，并且在ingress的前面还有一层是华为云的ELB（华为云的ELB不支持后端协议为tcp，所以这里只能将dashboard的ssl关掉，在ELB层配置https），</p>
<p>如下图所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mon:</span></span><br><span class="line">        <span class="comment"># Set the number of mons to be started. Generally recommended to be 3.</span></span><br><span class="line">        <span class="comment"># For highest availability, an odd number of mons should be specified.</span></span><br><span class="line">        <span class="attr">count:</span> <span class="number">3</span></span><br><span class="line">        <span class="comment"># The mons should be on unique nodes. For production, at least 3 nodes are recommended for this reason.</span></span><br><span class="line">        <span class="comment"># Mons should only be allowed on the same node for test environments where data loss is acceptable.</span></span><br><span class="line">        <span class="attr">allowMultiplePerNode:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mgr:</span></span><br><span class="line">        <span class="comment"># When higher availability of the mgr is needed, increase the count to 2.</span></span><br><span class="line">        <span class="comment"># In that case, one mgr will be active and one in standby. When Ceph updates which</span></span><br><span class="line">        <span class="comment"># mgr is active, Rook will update the mgr services to match the active mgr.</span></span><br><span class="line">        <span class="attr">count:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">modules:</span></span><br><span class="line">          <span class="comment"># Several modules should not need to be included in this list. The "dashboard" and "monitoring" modules</span></span><br><span class="line">          <span class="comment"># are already enabled by other settings in the cluster CR.</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pg_autoscaler</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># enable the ceph dashboard for viewing cluster status</span></span><br><span class="line"><span class="attr">dashboard:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># serve the dashboard under a subpath (useful when you are accessing the dashboard via a reverse proxy)</span></span><br><span class="line">        <span class="comment"># urlPrefix: /ceph-dashboard</span></span><br><span class="line">        <span class="comment"># serve the dashboard at the given port.</span></span><br><span class="line">        <span class="comment"># port: 8443</span></span><br><span class="line">        <span class="comment"># serve the dashboard using SSL</span></span><br><span class="line">        <span class="comment"># ssl: true</span></span><br><span class="line">      <span class="comment"># enable prometheus alerting for cluster</span></span><br><span class="line"><span class="attr">monitoring:</span></span><br><span class="line">        <span class="comment"># requires Prometheus to be pre-installed</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">        <span class="comment"># namespace to deploy prometheusRule in. If empty, namespace of the cluster will be used.</span></span><br><span class="line">        <span class="comment"># Recommended:</span></span><br><span class="line">        <span class="comment"># If you have a single rook-ceph cluster, set the rulesNamespace to the same namespace as the cluster or keep it empty.</span></span><br><span class="line">        <span class="comment"># If you have multiple rook-ceph clusters in the same k8s cluster, choose the same namespace (ideally, namespace with prometheus</span></span><br><span class="line">        <span class="comment"># deployed) to set rulesNamespace for all the clusters. Otherwise, you will get duplicate alerts with multiple alert definitions.</span></span><br><span class="line">        <span class="attr">rulesNamespace:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blob.hixforever.com/image-20220129150923306.png" alt=""></p>
</li>
</ul>
</li>
<li><p>部署Rook Operator</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rook/deploy/examples</span><br><span class="line">kubectl apply -f crds.yaml -f common.yaml -f operator.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>创建Ceph集群</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f cluster.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>检测Ceph集群是否正常。如下图所示</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n rook-ceph get pod</span><br></pre></td></tr></table></figure>
<p> <img src="https://blob.hixforever.com/image-20220129151854831.png" alt=""></p>
</li>
</ol>
<h2 id="二、搭建Ceph-Dashboard面板"><a href="#二、搭建Ceph-Dashboard面板" class="headerlink" title="二、搭建Ceph Dashboard面板"></a><strong>二、搭建Ceph Dashboard面板</strong></h2><ol>
<li><p>配置在集群外部查看Dashboard。这里我们使用service http的NodePort模式。这个时候我们会发现Dashboard并不可以访问，解决办法看2</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rook/deploy/examples</span><br><span class="line">kubectl create -f dashboard-external-http.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>检测mgr主备高可用模式下哪个pod真正能用<br>由于主备模式下有一个Pod是不能用的，所以在配置service的时候可能代理的mgr pod不能用，所以导致Dashboard不能访问。</p>
<ul>
<li><p>找到第一步查看上面的svc。我们看到pod所在的端口(targetPort)是7000</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">rook-ceph-mgr-dashboard-external-http</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">rook-ceph</span> <span class="comment"># namespace:cluster</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">rook-ceph-mgr</span></span><br><span class="line">    <span class="attr">rook_cluster:</span> <span class="string">rook-ceph</span> <span class="comment"># namespace:cluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">7000</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">rook-ceph-mgr</span></span><br><span class="line">    <span class="attr">ceph_daemon_id:</span> <span class="string">a</span></span><br><span class="line">    <span class="attr">rook_cluster:</span> <span class="string">rook-ceph</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到mgr的两个podIP地址</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n rook-ceph get pod -owide</span><br></pre></td></tr></table></figure>
<p>  <img src="https://blob.hixforever.com/image-20220129154431024.png" alt=""></p>
</li>
<li><p>使用curl访问7000端口查看哪个Pod正常返回</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 10.244.8.83:7000</span><br><span class="line">curl 10.244.68.188:7000</span><br></pre></td></tr></table></figure>
<p>  <img src="https://blob.hixforever.com/image-20220129154540460.png" alt=""></p>
</li>
<li><p>查看这两个pod的lables信息，并找到ceph_daemon_id信息</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n rook-ceph --show-labels</span><br></pre></td></tr></table></figure>
<p>  <img src="https://blob.hixforever.com/image-20220129154825543.png" alt=""></p>
</li>
<li><p>修改dashboard-external-http.yaml文件。在selector中加上可用Pod的ceph_daemon_id</p>
  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">rook-ceph-mgr</span></span><br><span class="line">            <span class="attr">ceph_daemon_id:</span> <span class="string">a</span></span><br><span class="line">            <span class="attr">rook_cluster:</span> <span class="string">rook-ceph</span></span><br></pre></td></tr></table></figure>
<p>  <img src="https://blob.hixforever.com/image-20220129155034381.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>重新加载dashboard-external-http.yaml service。这次发现使用公网ip+Nodeport可以正常访问Dashboard</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f dashboard-external-http.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>创建 ingress文件dashboard-ingress-http.yaml</p>
 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example is for Kubernetes running an ngnix-ingress</span></span><br><span class="line"><span class="comment"># and an ACME (e.g. Let's Encrypt) certificate service</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The nginx-ingress annotations support the dashboard</span></span><br><span class="line"><span class="comment"># running using HTTPS with a self-signed certificate</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">rook-ceph-mgr-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">rook-ceph</span> <span class="comment"># namespace:cluster</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ingressClassName:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">rookceph.zuoyejia.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">            <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">service:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">rook-ceph-mgr-dashboard-external-http</span></span><br><span class="line">                <span class="attr">port:</span></span><br><span class="line">                  <span class="attr">number:</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>加载ingress</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f dashboard-ingress-http.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li>注意：本文第4、5部需要使用ingress-nginx和华为云的ELB。如果没有的话直接使用官方文档上的文件。再次提醒，service上必须加上可以访问正常Pod的选择器。</li>
</ol>
<h2 id="三、Ceph存储"><a href="#三、Ceph存储" class="headerlink" title="三、Ceph存储"></a><strong>三、Ceph存储</strong></h2><h3 id="1-1-块存储-RBD"><a href="#1-1-块存储-RBD" class="headerlink" title="1.1 块存储(RBD)"></a><strong>1.1 块存储(RBD)</strong></h3><p>RDB： RADOS Block Devices</p>
<p>RADOS： Reliable, Autonomic Distributed Object Store</p>
<ol>
<li><p>配置<br>RWO:（ReadWriteOnce）<br>常用 块存储 。RWO模式；STS删除，pvc不会删除，需要自己手动维护</p>
<p> <a href="https://www.rook.io/docs/rook/v1.8/ceph-block.html" target="_blank" rel="noopener">https://www.rook.io/docs/rook/v1.8/ceph-block.html</a></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f deploy/examples/csi/rbd/storageclass.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="1-2-共享文件存储-CephFS"><a href="#1-2-共享文件存储-CephFS" class="headerlink" title="1.2 共享文件存储(CephFS)"></a><strong>1.2 共享文件存储(CephFS)</strong></h3><ol>
<li><p>配置<br>常用 文件存储。 RWX模式；如：10个Pod共同操作一个地方<br><a href="https://rook.io/docs/rook/v1.8/ceph-filesystem.html" target="_blank" rel="noopener">https://rook.io/docs/rook/v1.8/ceph-filesystem.html</a></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rook</span><br><span class="line">kubectl apply -f filesystem.yaml</span><br><span class="line">kubectl create -f deploy/examples/csi/cephfs/storageclass.yaml</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="四、卸载Rook-Ceph"><a href="#四、卸载Rook-Ceph" class="headerlink" title="四、卸载Rook Ceph"></a>四、卸载Rook Ceph</h2><p>参考：<a href="https://rook.io/docs/rook/v1.8/ceph-teardown.html" target="_blank" rel="noopener">https://rook.io/docs/rook/v1.8/ceph-teardown.html</a></p>
<h3 id="1-清理集群"><a href="#1-清理集群" class="headerlink" title="1. 清理集群"></a>1. 清理集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/rook</span><br></pre></td></tr></table></figure>
<h3 id="2-删除块和部署的文件"><a href="#2-删除块和部署的文件" class="headerlink" title="2.删除块和部署的文件"></a>2.删除块和部署的文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f crds.yaml -f common.yaml -f operator.yaml</span><br><span class="line">kubectl delete -f cluster.yaml</span><br><span class="line">kubectl delete -n rook-ceph cephblockpool replicapool</span><br><span class="line">kubectl delete storageclass rook-ceph-block</span><br></pre></td></tr></table></figure>
<h3 id="3-删除CephCluster-CRD"><a href="#3-删除CephCluster-CRD" class="headerlink" title="3.删除CephCluster CRD"></a>3.删除<strong>CephCluster CRD</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.编辑CephCluster并添加cleanupPolicy</span></span><br><span class="line"><span class="comment"># 2.删除CephClusterCR</span></span><br><span class="line"><span class="comment"># 3.确认已删除集群 CR</span></span><br><span class="line">kubectl -n rook-ceph patch cephcluster rook-ceph --<span class="built_in">type</span> merge -p <span class="string">'&#123;"spec":&#123;"cleanupPolicy":&#123;"confirmation":"yes-really-destroy-data"&#125;&#125;&#125;'</span></span><br><span class="line">kubectl -n rook-ceph delete cephcluster rook-ceph</span><br><span class="line">kubectl -n rook-ceph get cephcluster</span><br></pre></td></tr></table></figure>
<h3 id="4-删除Operator-及相关资源"><a href="#4-删除Operator-及相关资源" class="headerlink" title="4.删除Operator 及相关资源"></a>4.删除<strong>Operator 及相关资源</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f operator.yaml</span><br><span class="line">kubectl delete -f common.yaml</span><br><span class="line">kubectl delete -f crds.yaml</span><br></pre></td></tr></table></figure>
<h3 id="5-删除主机上的数据"><a href="#5-删除主机上的数据" class="headerlink" title="5.删除主机上的数据"></a>5.删除<strong>主机上的数据</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISK=<span class="string">"/dev/vdb"</span></span><br><span class="line">sgdisk --zap-all <span class="variable">$DISK</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="string">"<span class="variable">$DISK</span>"</span> bs=1M count=100 oflag=direct,dsync</span><br><span class="line"><span class="comment"># 如果是SSD</span></span><br><span class="line"><span class="comment"># blkdiscard $DISK</span></span><br><span class="line">partprobe <span class="variable">$DISK</span></span><br><span class="line"></span><br><span class="line">ls /dev/mapper/ceph-* | xargs -I% -- dmsetup remove %</span><br><span class="line">rm -rf /dev/ceph-*</span><br><span class="line">rm -rf /dev/mapper/ceph--*</span><br></pre></td></tr></table></figure>
<h3 id="6-故障排除"><a href="#6-故障排除" class="headerlink" title="6.故障排除"></a>6.故障排除</h3><ul>
<li><p>查看Pod</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n rook-ceph get pod</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>查看集群CRD</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n rook-ceph get cephcluster</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除CRD</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除CRD</span></span><br><span class="line"><span class="keyword">for</span> CRD <span class="keyword">in</span> $(kubectl get crd -n rook-ceph | awk <span class="string">'/ceph.rook.io/ &#123;print $1&#125;'</span>); <span class="keyword">do</span></span><br><span class="line">    kubectl get -n rook-ceph <span class="string">"<span class="variable">$CRD</span>"</span> -o name | \</span><br><span class="line">    xargs -I &#123;&#125; kubectl patch -n rook-ceph &#123;&#125; --<span class="built_in">type</span> merge -p <span class="string">'&#123;"metadata":&#123;"finalizers": [null]&#125;&#125;'</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>如果如果namespace仍然停留在Terminting状态，可以检查哪些资源正在阻止删除并删除finalizers并删除</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources --verbs=list --namespaced -o name \</span><br><span class="line">  | xargs -n 1 kubectl get --show-kind --ignore-not-found -n rook-ceph</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>删除finalizers资源</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n rook-ceph patch configmap rook-ceph-mon-endpoints --<span class="built_in">type</span> merge -p <span class="string">'&#123;"metadata":&#123;"finalizers": []&#125;&#125;'</span></span><br><span class="line">kubectl -n rook-ceph patch secrets rook-ceph-mon --<span class="built_in">type</span> merge -p <span class="string">'&#123;"metadata":&#123;"finalizers": []&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果cluster和replicapool存在执行下面命令</span></span><br><span class="line">kubectl -n rook-ceph patch cephclusters.ceph.rook.io rook-ceph -p <span class="string">'&#123;"metadata":&#123;"finalizers": []&#125;&#125;'</span> --<span class="built_in">type</span>=merge</span><br><span class="line">kubectl -n rook-ceph patch cephblockpool.ceph.rook.io replicapool -p <span class="string">'&#123;"metadata":&#123;"finalizers": []&#125;&#125;'</span> --<span class="built_in">type</span>=merge</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/01/nginx-keepalived/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/01/nginx-keepalived/" itemprop="url">搭建Keepalived Nginx高可用Web集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-01T14:23:58+08:00">
                2021-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/Keepalived/" itemprop="url" rel="index">
                    <span itemprop="name">Keepalived</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="搭建Keepalived-Nginx高可用服务集群"><a href="#搭建Keepalived-Nginx高可用服务集群" class="headerlink" title="搭建Keepalived + Nginx高可用服务集群"></a>搭建Keepalived + Nginx高可用服务集群</h3><h4 id="一、操作场景"><a href="#一、操作场景" class="headerlink" title="一、操作场景"></a>一、操作场景</h4><p>虚拟IP（VIP）主要用于弹性云服务器的主备切换，达到高可用性HA（High Availability）的目的。当主服务器发生故障无法对外提供服务时，动态将虚拟IP切换到备服务器，继续对外提供服务。</p>
<p>本文档以弹性云服务器的CentOS 7.5 64位操作系统为例，实现Keepalived+Nginx高可用服务集群搭建。</p>
<h4 id="二、背景知识"><a href="#二、背景知识" class="headerlink" title="二、背景知识"></a>二、背景知识</h4><h4 id="三、网络拓扑"><a href="#三、网络拓扑" class="headerlink" title="三、网络拓扑"></a>三、网络拓扑</h4><p>数据规划如下：</p>
<p>表1 数据规划</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>产品</th>
<th>数量</th>
<th>规格</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>虚拟私有云（VPC）</td>
<td>1</td>
<td>192.168.0.0/16</td>
</tr>
<tr>
<td></td>
<td>子网（subnet）</td>
<td>1</td>
<td>192.168.0.0/24</td>
</tr>
<tr>
<td>2</td>
<td>弹性云服务器（ECS）</td>
<td>2</td>
<td>4vCPUs 8GB CentOS 7.5 64bit</td>
</tr>
<tr>
<td></td>
<td>子网IP（subnet IP）</td>
<td>2</td>
<td>ecs-HA1：192.168.192.39<br>ecs-HA2：192.168.192.41</td>
</tr>
<tr>
<td>3</td>
<td>弹性公网IP（EIP）</td>
<td>1</td>
<td>116.63.115.186</td>
</tr>
<tr>
<td></td>
<td>虚拟IP（VIP）</td>
<td>1</td>
<td>192.168.192.100</td>
</tr>
</tbody>
</table>
<p>实现方式如下：</p>
<ul>
<li>将2台同子网的弹性云服务器配置Keepalived，一台为主服务器，一台为备份服务器。</li>
<li>将这2台弹性云服务器绑定同一个虚拟IP。</li>
<li>将虚拟IP与弹性公网IP绑定，从互联网可以访问绑定了该虚拟IP地址的主备云服务器。</li>
</ul>
<p>图1 组网图</p>
<p><img src="https://blob.hixforever.com/20211208132827.png" alt=""></p>
<h4 id="三、操作步骤"><a href="#三、操作步骤" class="headerlink" title="三、操作步骤"></a>三、操作步骤</h4><h5 id="1-nginx"><a href="#1-nginx" class="headerlink" title="1. nginx"></a>1. nginx</h5><h6 id="1-1-在ECS-HA1和ECS-HA2分别安装Nginx"><a href="#1-1-在ECS-HA1和ECS-HA2分别安装Nginx" class="headerlink" title="1.1 在ECS-HA1和ECS-HA2分别安装Nginx"></a>1.1 在ECS-HA1和ECS-HA2分别安装Nginx</h6><ul>
<li><p>RPM包地址：<a href="http://nginx.org/packages/centos/7/x86_64/RPMS/" target="_blank" rel="noopener">http://nginx.org/packages/centos/7/x86_64/RPMS/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://nginx.org/packages/centos/7/x86_64/RPMS/nginx-1.20.2-1.el7.ngx.x86_64.rpm </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rpm -ivh nginx-1.20.2-1.el7.ngx.x86_64.rpm</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>yum安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl start nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl status nginx</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="1-2-配置Nginx"><a href="#1-2-配置Nginx" class="headerlink" title="1.2 配置Nginx"></a>1.2 配置Nginx</h6><ul>
<li><p>主机ECS-HA1 nginx.conf配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /mnt/sse/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span></span><br><span class="line">                      <span class="string">'"rl=<span class="variable">$request_length</span>" <span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>"'</span></span><br><span class="line">                      <span class="string">'rt=<span class="variable">$request_time</span> uct="<span class="variable">$upstream_connect_time</span>" uht="<span class="variable">$upstream_header_time</span>" urt="<span class="variable">$upstream_response_time</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /mnt/sse/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate "/etc/pki/nginx/server.crt";</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key "/etc/pki/nginx/private/server.key";</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主机ECS-HA1 /usr/share/nginx/html/index.html修改</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to ECS-HA1</span><br></pre></td></tr></table></figure>
</li>
<li><p>备机ECS-HA2 nginx.conf配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">error_log</span> /mnt/sse/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span></span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span></span><br><span class="line">                      <span class="string">'"rl=<span class="variable">$request_length</span>" <span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>"'</span></span><br><span class="line">                      <span class="string">'rt=<span class="variable">$request_time</span> uct="<span class="variable">$upstream_connect_time</span>" uht="<span class="variable">$upstream_header_time</span>" urt="<span class="variable">$upstream_response_time</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /mnt/sse/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings for a TLS enabled server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    server &#123;</span></span><br><span class="line"><span class="comment">#        listen       443 ssl http2;</span></span><br><span class="line"><span class="comment">#        listen       [::]:443 ssl http2;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line"><span class="comment">#        root         /usr/share/nginx/html;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        ssl_certificate "/etc/pki/nginx/server.crt";</span></span><br><span class="line"><span class="comment">#        ssl_certificate_key "/etc/pki/nginx/private/server.key";</span></span><br><span class="line"><span class="comment">#        ssl_session_cache shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#        ssl_session_timeout  10m;</span></span><br><span class="line"><span class="comment">#        ssl_ciphers HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#        ssl_prefer_server_ciphers on;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        # Load configuration files for the default server block.</span></span><br><span class="line"><span class="comment">#        include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 404 /404.html;</span></span><br><span class="line"><span class="comment">#            location = /40x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#        error_page 500 502 503 504 /50x.html;</span></span><br><span class="line"><span class="comment">#            location = /50x.html &#123;</span></span><br><span class="line"><span class="comment">#        &#125;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备机ECS-HA2  /usr/share/nginx/html/index.html修改</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Welcome to ECS-HA2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-Keepalived"><a href="#2-Keepalived" class="headerlink" title="2. Keepalived"></a>2. Keepalived</h5><h6 id="1-1-在ECS-HA1和ECS-HA2分别安装Keepalived"><a href="#1-1-在ECS-HA1和ECS-HA2分别安装Keepalived" class="headerlink" title="1.1 在ECS-HA1和ECS-HA2分别安装Keepalived"></a>1.1 在ECS-HA1和ECS-HA2分别安装Keepalived</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ wget --no-check-certificate https://www.keepalived.org/software/keepalived-2.2.4.tar.gz</span><br><span class="line">$ tar -xvzf keepalived-2.2.4.tar.gz</span><br><span class="line">$ yum -y install openssl-devel</span><br><span class="line">$ <span class="built_in">cd</span> keepalived-2.2.4/</span><br><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line">$ mkdir /etc/keepalived</span><br><span class="line">$ cp /usr/<span class="built_in">local</span>/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf</span><br><span class="line">$ cp /usr/<span class="built_in">local</span>/keepalived/etc/sysconfig/keepalived /etc/sysconfig/keepalived</span><br><span class="line"><span class="comment"># 修改/lib/systemd/system/keepalived.service，设置EnvironmentFile=-/etc/sysconfig/keepalived</span></span><br><span class="line">$ vim /lib/systemd/system/keepalived.service</span><br><span class="line">$ systemctl start keepalived</span><br><span class="line">$ systemctl <span class="built_in">enable</span> keepalived</span><br><span class="line">$ systemctl status keepalived.service</span><br></pre></td></tr></table></figure>
<h6 id="1-2-配置主机ECS-HA1Keepalived"><a href="#1-2-配置主机ECS-HA1Keepalived" class="headerlink" title="1.2 配置主机ECS-HA1Keepalived"></a>1.2 配置主机ECS-HA1Keepalived</h6><ul>
<li><p>编辑keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id master-node</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    script  "/etc/keepalived/chk_nginx.sh"</span><br><span class="line">    interval 2</span><br><span class="line">    weight -5</span><br><span class="line">    fall 2</span><br><span class="line">    rise 1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">     state MASTER</span><br><span class="line">     interface eth0</span><br><span class="line">     mcast_src_ip 192.168.192.39</span><br><span class="line">     virtual_router_id 51</span><br><span class="line">     priority 101</span><br><span class="line">     advert_int 1</span><br><span class="line">     authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">     &#125;</span><br><span class="line">     unicast_src_ip 192.168.192.39</span><br><span class="line">     virtual_ipaddress &#123;</span><br><span class="line">         192.168.192.100</span><br><span class="line">     &#125;</span><br><span class="line">    notify_master "/etc/keepalived/keepalived_notify.sh MASTER" # 当切换到master状态时执行脚本</span><br><span class="line">    notify_backup "/etc/keepalived/keepalived_notify.sh BACKUP" # 当切换到backup状态时执行脚本</span><br><span class="line">    notify_fault "/etc/keepalived/keepalived_notify.sh FAULT" # 当切换到fault状态时执行脚本</span><br><span class="line">    notify_stop "/etc/keepalived/keepalived_notify.sh STOP" # 当切换到stop状态时执行脚本</span><br><span class="line">    garp_master_delay 1    # 设置当切为主状态后多久更新ARP缓存</span><br><span class="line">    garp_master_refresh 5   # 设置主节点发送ARP报文的时间间隔</span><br><span class="line">    # 跟踪接口，里面任意一块网卡出现问题，都会进入故障(FAULT)状态</span><br><span class="line">    track_interface &#123;</span><br><span class="line">      eth0</span><br><span class="line">    &#125;</span><br><span class="line">     track_script &#123;</span><br><span class="line">         chk_http_port</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>/etc/keepalived/chk_nginx.sh</code>脚本文件，使用<code>chmod +x /etc/keepalived/chk_nginx.sh</code>将文件变成可执行文件，并增加如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;counter&#125;</span>"</span> = <span class="string">"0"</span>  ]; <span class="keyword">then</span></span><br><span class="line">     systemctl start nginx.service</span><br><span class="line">     sleep 2</span><br><span class="line">     counter=$(ps -C nginx  --no-heading|wc -l)</span><br><span class="line">     <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;counter&#125;</span>"</span> =  <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">          systemctl stop keepalived.service</span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>创建<code>/etc/keepalived/keepalived_notify</code>脚本文件，使用<code>chmod +x /etc/keepalived/keepalived_notify</code>将文件变成可执行文件，并增加如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2021 He Chen &lt;chenhe@zuoyejia.com&gt;. All rights reserved.</span></span><br><span class="line"><span class="comment"># Use of this source code is governed by a MIT style</span></span><br><span class="line"><span class="comment"># license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/keepalived/keepalived_notify.sh</span></span><br><span class="line">log_file=/var/<span class="built_in">log</span>/keepalived.log</span><br><span class="line"></span><br><span class="line">sse::keepalived::<span class="function"><span class="title">mail</span></span>() &#123;</span><br><span class="line">  <span class="comment"># 这里可以添加email逻辑，当keepalived变动时及时告警</span></span><br><span class="line">  :</span><br><span class="line"> sendEmail -f chenhe@zuoyejia.com -t chenhe@zuoyejia.com -s <span class="string">"smtp.exmail.qq.com:587"</span> -u <span class="string">"作业家Nginx+Keepalived状态通知"</span> -o message-charset=utf-8 -xu chenhe@zuoyejia.com -xp agcCeRn3v42Cohkk -m <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">sse::keepalived::<span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"[`date '+%Y-%m-%d %T'`] <span class="variable">$1</span>"</span> &gt;&gt; <span class="variable">$&#123;log_file&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ ! -d /var/keepalived/ ] &amp;&amp; mkdir -p /var/keepalived/</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"MASTER"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"notify_master"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"notify_master"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"BACKUP"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"notify_backup"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"notify_backup"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"FAULT"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"notify_fault"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"notify_fault"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"STOP"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"notify_stop"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"notify_stop"</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"keepalived_notify.sh: state error!"</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="1-3-配置备机ECS-HA2-Keepalived"><a href="#1-3-配置备机ECS-HA2-Keepalived" class="headerlink" title="1.3 配置备机ECS-HA2 Keepalived"></a>1.3 配置备机ECS-HA2 Keepalived</h6><ul>
<li><p>编辑keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改keepalived.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id master-node</span><br><span class="line">    script_user root</span><br><span class="line">    enable_script_security</span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">     script  "/etc/keepalived/chk_nginx.sh"</span><br><span class="line">     interval 2</span><br><span class="line">     weight -5</span><br><span class="line">     fall 2</span><br><span class="line">     rise 1</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">     state BACKUP</span><br><span class="line">     interface eth0</span><br><span class="line">     mcast_src_ip 192.168.192.41</span><br><span class="line">     virtual_router_id 51</span><br><span class="line">     priority 100</span><br><span class="line">     advert_int 1</span><br><span class="line">     authentication &#123;</span><br><span class="line">          auth_type PASS</span><br><span class="line">          auth_pass 1111</span><br><span class="line">     &#125;</span><br><span class="line">    unicast_src_ip 192.168.192.41</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.192.100</span><br><span class="line">    &#125;</span><br><span class="line">    notify_master "/etc/keepalived/keepalived_notify.sh MASTER" # 当切换到master状态时执行脚本</span><br><span class="line">    notify_backup "/etc/keepalived/keepalived_notify.sh BACKUP" # 当切换到backup状态时执行脚本</span><br><span class="line">    notify_fault "/etc/keepalived/keepalived_notify.sh FAULT" # 当切换到fault状态时执行脚本</span><br><span class="line">    notify_stop "/etc/keepalived/keepalived_notify.sh STOP" # 当切换到stop状态时执行脚本</span><br><span class="line">    garp_master_delay 1    # 设置当切为主状态后多久更新ARP缓存</span><br><span class="line">    garp_master_refresh 5   # 设置主节点发送ARP报文的时间间隔</span><br><span class="line">    # 跟踪接口，里面任意一块网卡出现问题，都会进入故障(FAULT)状态</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_http_port</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>/etc/keepalived/chk_nginx.sh</code>脚本文件，使用<code>chmod +x /etc/keepalived/chk_nginx.sh</code>将文件变成可执行文件，并增加如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">counter=$(ps -C nginx --no-heading|wc -l)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;counter&#125;</span>"</span> = <span class="string">"0"</span>  ]; <span class="keyword">then</span></span><br><span class="line">     systemctl start nginx.service</span><br><span class="line">     sleep 2</span><br><span class="line">     counter=$(ps -C nginx  --no-heading|wc -l)</span><br><span class="line">     <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;counter&#125;</span>"</span> =  <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">          systemctl stop keepalived.service</span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>创建<code>/etc/keepalived/keepalived_notify</code>脚本文件，使用<code>chmod +x /etc/keepalived/keepalived_notify</code>将文件变成可执行文件，并增加如下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2021 He Chen &lt;chenhe@zuoyejia.com&gt;. All rights reserved.</span></span><br><span class="line"><span class="comment"># Use of this source code is governed by a MIT style</span></span><br><span class="line"><span class="comment"># license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/keepalived/keepalived_notify.sh</span></span><br><span class="line">log_file=/var/<span class="built_in">log</span>/keepalived.log</span><br><span class="line"></span><br><span class="line">sse::keepalived::<span class="function"><span class="title">mail</span></span>() &#123;</span><br><span class="line">  <span class="comment"># 这里可以添加email逻辑，当keepalived变动时及时告警</span></span><br><span class="line">  :</span><br><span class="line"> sendEmail -f chenhe@zuoyejia.com -t chenhe@zuoyejia.com -s <span class="string">"smtp.exmail.qq.com:587"</span> -u <span class="string">"作业家Nginx+Keepalived备机状态通知"</span> -o message-charset=utf-8 -xu chenhe@zuoyejia.com -xp agcCeRn3v42Cohkk -m <span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">sse::keepalived::<span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"[`date '+%Y-%m-%d %T'`] <span class="variable">$1</span>"</span> &gt;&gt; <span class="variable">$&#123;log_file&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ ! -d /var/keepalived/ ] &amp;&amp; mkdir -p /var/keepalived/</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"MASTER"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"nginx backpu notify_master"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"nginx backpu notify_master"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"BACKUP"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"nginx backpu notify_backup"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"nginx backpu notify_backup"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"FAULT"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"nginx backpu notify_fault"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"nginx backpu notify_fault"</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"STOP"</span> )</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"nginx backpu notify_stop"</span></span><br><span class="line">        sse::keepalived::mail <span class="string">"nginx backpu notify_stop"</span></span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        sse::keepalived::<span class="built_in">log</span> <span class="string">"nginx backpu keepalived_notify.sh: state error!"</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-sendEmail"><a href="#3-sendEmail" class="headerlink" title="3. sendEmail"></a>3. sendEmail</h5><h6 id="1-1-在ECS-HA1和ECS-HA2分别安装sendEmail"><a href="#1-1-在ECS-HA1和ECS-HA2分别安装sendEmail" class="headerlink" title="1.1 在ECS-HA1和ECS-HA2分别安装sendEmail"></a>1.1 在ECS-HA1和ECS-HA2分别安装sendEmail</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install sendEmail</span><br></pre></td></tr></table></figure>
<h6 id="1-2-以腾讯企业邮箱为例，配置安全密码"><a href="#1-2-以腾讯企业邮箱为例，配置安全密码" class="headerlink" title="1.2. 以腾讯企业邮箱为例，配置安全密码"></a>1.2. 以腾讯企业邮箱为例，配置安全密码</h6><ul>
<li><p>登录腾讯企业邮箱，打开设置</p>
<p><img src="https://blob.hixforever.com/20211208142608.png" alt=""></p>
</li>
<li><p>选择安全设置，生成专用密码。（如果没开启安全登录，点击开启）<br><img src="https://blob.hixforever.com/20211208142729.png" alt=""></p>
</li>
<li><p>将安全密码写入<code>/etc/keepalived/keepalived_notify</code>脚本文件中</p>
</li>
</ul>
<h5 id="4-重启ECS-HA1和ECS-HA2-Nginx、Keepalived"><a href="#4-重启ECS-HA1和ECS-HA2-Nginx、Keepalived" class="headerlink" title="4. 重启ECS-HA1和ECS-HA2 Nginx、Keepalived"></a>4. 重启ECS-HA1和ECS-HA2 Nginx、Keepalived</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nginx -s reload</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl restart keepalived</span></span><br></pre></td></tr></table></figure>
<h5 id="5-绑定虚拟IP"><a href="#5-绑定虚拟IP" class="headerlink" title="5. 绑定虚拟IP"></a>5. 绑定虚拟IP</h5><ol>
<li>登录管理控制台。</li>
<li>选择“服务列表 &gt; 网络 &gt; 虚拟私有云”。</li>
<li>在左侧导航栏选择“子网”。</li>
<li>在“子网”列表中，单击子网名称。</li>
<li>选择“IP地址管理”页签，在虚拟IP所在行的操作列下单击“绑定服务器”。</li>
<li>在弹出的页面，选择ecs HA1和ecs HA2服务器。</li>
<li>选择“IP地址管理”页签，在虚拟IP所在行的操作列下单击“绑定弹性公网IP”。</li>
<li>在弹出的页面，选择弹性公网IP <code>116.63.115.186</code></li>
</ol>
<h5 id="6-域名解析"><a href="#6-域名解析" class="headerlink" title="6. 域名解析"></a>6. 域名解析</h5><p>添加A类DNS域名解析，将sseserverzj2.zuoyejia.com绑定为上述公网ip</p>
<h5 id="7-验证结果"><a href="#7-验证结果" class="headerlink" title="7. 验证结果"></a>7. 验证结果</h5><ol>
<li><p>通过管理控制台远程登录到ecs-HA1。</p>
</li>
<li><p>执行以下命令，查看虚拟IP是否有绑定到ecs-HA1的eth0网卡上。<br><strong>ip addr show</strong></p>
<p>如下图所示表示虚拟IP已经绑定到ecs-HA1的eth0网卡上。<br><img src="https://blob.hixforever.com/20211208143732.png" alt=""></p>
</li>
<li><p>访问验证ecs-HA1<br><img src="https://blob.hixforever.com/20211208144326.png" alt=""></p>
</li>
<li><p>执行以下命令，停止ecs-HA1上的keepalived服务。<br><strong>systemctl stop keepalived.service</strong></p>
</li>
<li><p>执行以下命令，查看服务器ecs-HA2是否有接管虚拟IP。<br><strong>ip addr show</strong><br>如果所示<br><img src="https://blob.hixforever.com/20211208144503.png" alt=""></p>
</li>
<li><p>访问验证ecs-HA2<br><img src="https://blob.hixforever.com/20211208144559.png" alt=""></p>
</li>
<li><p>查看自己的邮箱是否有keepalived的状态邮件<br><img src="https://blob.hixforever.com/image-20211208144744870.png" alt="image-20211208144744870"></p>
</li>
</ol>
<h4 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h4><h5 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不停止对客户服务的情况下，重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/07/redis-redis-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/07/redis-redis-stream/" itemprop="url">基于Redis的消息队列解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-07T17:31:33+08:00">
                2021-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现在的互联网应用基本上都是采用分布式系统架构进行设计的，而很多分布式系统必备的一个基础软件就是消息队列。</p>
<p>消息队列要能支持组件通信消息的快速读写，而 Redis 本身支持数据的高速访问，正好可以满足消息队列的读写性能需求。不过，除了性能，消息队列还有其他的要求，所以，很多人都很关心一个问题：“Redis 适合做消息队列吗？”</p>
<p>其实，这个问题的背后，隐含着两方面的核心问题：</p>
<ul>
<li>消息队列的消息存取需求是什么？</li>
<li>Redis 如何实现消息队列的需求？</li>
</ul>
<p>只有把这两方面的知识和实践经验串连起来，才能彻底理解基于 Redis 实现消息队列的技术实践。以后需要为分布式系统组件做消息队列选型时，就可以根据组件通信量和消息通信速度的要求，选择出适合的 Redis 消息队列方案。目前使用Redis做消息队列可以有如下三种方式。</p>
<p><img src="https://blob.hixforever.com/image-20210907174320617.png" alt="image-20210907174320617"></p>
<h3 id="一、消息队列的消息存取需求"><a href="#一、消息队列的消息存取需求" class="headerlink" title="一、消息队列的消息存取需求"></a>一、消息队列的消息存取需求</h3><p>在分布式系统中，当两个组件要基于消息队列进行通信时，一个组件会把要处理的数据以消息的形式传递给消息队列，然后，这个组件就可以继续执行其他操作了；远端的另一个组件从消息队列中把消息读取出来，再在本地进行处理。</p>
<p>假设组件 1 需要对采集到的数据进行求和计算，并写入数据库，但是，消息到达的速度很快，组件 1 没有办法及时地既做采集，又做计算，并且写入数据库。所以，我们可以使用基于消息队列的通信，让组件 1 把数据 x 和 y 保存为 JSON 格式的消息，再发到消息队列，这样它就可以继续接收新的数据了。组件 2 则异步地从消息队列中把数据读取出来，在服务器 2 上进行求和计算后，再写入数据库。这个过程如下图所示：</p>
<p><img src="https://blob.hixforever.com/20210907175533.png" alt=""></p>
<p>我们一般把消息队列中发送消息的组件称为生产者（例子中的组件 1），把接收消息的组件称为消费者（例子中的组件 2），下图展示了一个通用的消息队列的架构模型：</p>
<p><img src="https://blob.hixforever.com/20210907175616.png" alt=""></p>
<p>在使用消息队列时，消费者可以异步读取生产者消息，然后再进行处理。这样一来，即使生产者发送消息的速度远远超过了消费者处理消息的速度，生产者已经发送的消息也可以缓存在消息队列中，避免阻塞生产者，这是消息队列作为分布式组件通信的一大优势。</p>
<p><strong>不过，消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。</strong></p>
<ol>
<li><p>需求一：消息保序</p>
<p>虽然消费者是异步处理消息，但是，消费者仍然需要按照生产者发送消息的顺序来处理消息，避免后发送的消息被先处理了。对于要求消息保序的场景来说，一旦出现这种消息被乱序处理的情况，就可能会导致业务逻辑被错误执行，从而给业务方造成损失。</p>
</li>
<li><p>需求二：重复消息处理</p>
<p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</p>
</li>
<li><p>需求三：消息可靠性保证</p>
<p>消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p>
</li>
</ol>
<h3 id="二、基于-List-的消息队列解决方案"><a href="#二、基于-List-的消息队列解决方案" class="headerlink" title="二、基于 List 的消息队列解决方案"></a>二、基于 List 的消息队列解决方案</h3><p>首先，我们先从最简单的场景开始讲起。</p>
<p>如果你的业务需求足够简单，想把 Redis 当作队列来使用，肯定最先想到的就是使用 List 这个数据类型。</p>
<p>因为 List 底层的实现就是一个「链表」，在头部和尾部操作元素，时间复杂度都是 O(1)，这意味着它非常符合消息队列的模型。</p>
<p>如果把 List 当作队列，你可以这么来用。</p>
<p>生产者使用 LPUSH 发布消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH queue msg1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH queue msg2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
<p>消费者这一侧，使用 RPOP 拉取消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPOP queue</span><br><span class="line"><span class="string">"msg1"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP queue</span><br><span class="line"><span class="string">"msg2"</span></span><br></pre></td></tr></table></figure>
<p>这个模型非常简单，也很容易理解。</p>
<p><img src="https://blob.hixforever.com/20210908141846.png" alt=""></p>
<p>但这里有个小问题，当队列中已经没有消息了，消费者在执行 RPOP 时，会返回 NULL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; RPOP queue</span><br><span class="line"><span class="comment"># 没消息了</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
<p>而我们在编写消费者逻辑时，一般是一个「死循环」，这个逻辑需要不断地从队列中拉取消息进行处理，伪代码一般会这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">true</span>:</span><br><span class="line">    msg = redis.rpop(<span class="string">"queue"</span>)</span><br><span class="line">    <span class="comment">// 没有消息，继续循环</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="keyword">null</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handle(msg)</span><br></pre></td></tr></table></figure>
<p>如果此时队列为空，那消费者依旧会频繁拉取消息，这会造成「CPU 空转」，不仅浪费 CPU 资源，还会对 Redis 造成压力。</p>
<p>怎么解决这个问题呢？</p>
<p>也很简单，当队列为空时，我们可以「休眠」一会，再去尝试拉取消息。代码可以修改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">true</span>:</span><br><span class="line">    msg = redis.rpop(<span class="string">"queue"</span>)</span><br><span class="line">    <span class="comment">// 没有消息，休眠2s</span></span><br><span class="line">    <span class="keyword">if</span> msg == <span class="keyword">null</span>:</span><br><span class="line">        sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// 处理消息        </span></span><br><span class="line">    handle(msg)</span><br></pre></td></tr></table></figure>
<p>这就解决了 CPU 空转问题。</p>
<p>这个问题虽然解决了，但又带来另外一个问题：当消费者在休眠等待时，有新消息来了，那消费者处理新消息就会存在「延迟」。</p>
<p>假设设置的休眠时间是 2s，那新消息最多存在 2s 的延迟。</p>
<p>要想缩短这个延迟，只能减小休眠的时间。但休眠时间越小，又有可能引发 CPU 空转问题。</p>
<p>鱼和熊掌不可兼得。</p>
<p>那如何做，既能及时处理新消息，还能避免 CPU 空转呢？</p>
<p>Redis 是否存在这样一种机制：如果队列为空，消费者在拉取消息时就「阻塞等待」，一旦有新消息过来，就通知我的消费者立即处理新消息呢？</p>
<p>幸运的是，Redis 确实提供了「阻塞式」拉取消息的命令：BRPOP / BLPOP，这里的 B 指的是阻塞（Block）。</p>
<p><img src="https://blob.hixforever.com/20210908142213.png" alt=""></p>
<p>现在，你可以这样来拉取消息了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">true</span>:</span><br><span class="line">    <span class="comment">// 没消息阻塞等待，0表示不设置超时时间</span></span><br><span class="line">    msg = redis.brpop(<span class="string">"queue"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="keyword">null</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handle(msg)</span><br></pre></td></tr></table></figure>
<p>使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。</p>
<p>这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。</p>
<blockquote>
<p>使用 BRPOP 这种阻塞式方式拉取消息时，还支持传入一个「超时时间」，如果设置为 0，则表示不设置超时，直到有新消息才返回，否则会在指定的超时时间后返回 NULL。</p>
<p>这个方案不错，既兼顾了效率，还避免了 CPU 空转问题，一举两得。</p>
</blockquote>
<p>解决了消息处理不及时的问题，你可以再思考一下，这种队列模型，有什么缺点？</p>
<p>我们一起来分析一下：</p>
<ol>
<li><strong>不支持重复消费</strong>：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据</li>
<li><strong>消息丢失</strong>：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了</li>
</ol>
<p>第一个问题是功能上的，使用 List 做消息队列，它仅仅支持最简单的，一组生产者对应一组消费者，不能满足多组生产者和消费者的业务场景。</p>
<p>第二个问题就比较棘手了，因为从 List 中 POP 一条消息出来后，这条消息就会立即从链表中删除了。也就是说，无论消费者是否处理成功，这条消息都没办法再次消费了。</p>
<p>这也意味着，如果消费者在处理消息时异常宕机，那这条消息就相当于丢失了。</p>
<p>针对这 2 个问题怎么解决呢？我们一个个来看。</p>
<h3 id="三、基于-Pub-Sub-的消息队列解决方案"><a href="#三、基于-Pub-Sub-的消息队列解决方案" class="headerlink" title="三、基于 Pub/Sub 的消息队列解决方案"></a>三、基于 Pub/Sub 的消息队列解决方案</h3><p>从名字就能看出来，这个模块是 Redis 专门是针对「发布/订阅」这种队列模型设计的。</p>
<p>它正好可以解决前面提到的第一个问题：重复消费。</p>
<p>即多组生产者、消费者的场景，我们来看它是如何做的。</p>
<p>Redis 提供了 PUBLISH / SUBSCRIBE 命令，来完成发布、订阅的操作。</p>
<p><img src="https://blob.hixforever.com/20210907200807.png" alt=""></p>
<p>假设你想开启 2 个消费者，同时消费同一批数据，就可以按照以下方式来实现。</p>
<p>首先，使用 SUBSCRIBE 命令，启动 2 个消费者，并「订阅」同一个队列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2个消费者 都订阅一个队列</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE queue</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"queue"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>此时，2 个消费者都会被阻塞住，等待新消息的到来。</p>
<p>之后，再启动一个生产者，发布一条消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH queue msg1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>这时，2 个消费者就会解除阻塞，收到生产者发来的新消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE queue</span><br><span class="line"><span class="comment"># 收到新消息</span></span><br><span class="line">1) <span class="string">"message"</span></span><br><span class="line">2) <span class="string">"queue"</span></span><br><span class="line">3) <span class="string">"msg1"</span></span><br></pre></td></tr></table></figure>
<p>使用 Pub/Sub 这种方案，既支持阻塞式拉取消息，还很好地满足了多组消费者，消费同一批数据的业务需求。</p>
<p>除此之外，Pub/Sub 还提供了「匹配订阅」模式，允许消费者根据一定规则，订阅「多个」自己感兴趣的队列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 订阅符合规则的队列</span></span><br><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE queue.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"psubscribe"</span></span><br><span class="line">2) <span class="string">"queue.*"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>这里的消费者，订阅了 queue.* 相关的队列消息。</p>
<p>之后，生产者分别向 queue.p1 和 queue.p2 发布消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH queue.p1 msg1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH queue.p2 msg2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>这时再看消费者，它就可以接收到这 2 个生产者的消息了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE queue.*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 来自queue.p1的消息</span></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"queue.*"</span></span><br><span class="line">3) <span class="string">"queue.p1"</span></span><br><span class="line">4) <span class="string">"msg1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来自queue.p2的消息</span></span><br><span class="line">1) <span class="string">"pmessage"</span></span><br><span class="line">2) <span class="string">"queue.*"</span></span><br><span class="line">3) <span class="string">"queue.p2"</span></span><br><span class="line">4) <span class="string">"msg2"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://blob.hixforever.com/20210908133341.png" alt=""></p>
<p>我们可以看到，Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息。</p>
<p>讲完了它的优点，那它有什么缺点呢？</p>
<p>其实，Pub/Sub 最大问题是：<strong>丢数据</strong>。</p>
<p>如果发生以下场景，就有可能导致数据丢失：</p>
<ol>
<li>消费者下线</li>
<li>Redis 宕机</li>
<li>消息堆积</li>
</ol>
<p>究竟是怎么回事？</p>
<p>这其实与 Pub/Sub 的实现方式有很大关系。</p>
<p>Pub/Sub 在实现时非常简单，它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立「数据转发通道」，把符合规则的数据，从一端转发到另一端。</p>
<p>一个完整的发布、订阅消息处理流程是这样的：</p>
<ol>
<li>消费者订阅指定队列，Redis 就会记录一个映射关系：队列-&gt;消费者</li>
<li>生产者向这个队列发布消息，那 Redis 就从映射关系中找出对应的消费者，把消息转发给它</li>
</ol>
<p><img src="https://blob.hixforever.com/20210908133442.png" alt=""></p>
<p>整个过程中，没有任何的数据存储，一切都是实时转发的。</p>
<p>这种设计方案，就导致了上面提到的那些问题。</p>
<p>例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。</p>
<p>如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。</p>
<p>所以，当你在使用 Pub/Sub 时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p>
<p>这也是前面讲例子时，我们让消费者先订阅队列，之后才让生产者发布消息的原因。</p>
<p>另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。</p>
<p>也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。</p>
<p>最后，我们来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？</p>
<p>当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。</p>
<p>如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。</p>
<p>但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致<strong>消费失败和消息丢失</strong>！</p>
<p>这是怎么回事？</p>
<p>还是回到 Pub/Sub 的实现细节上来说。</p>
<p>每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。</p>
<p>当生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。</p>
<p>之后，消费者不断地从缓冲区读取消息，处理消息。看到了么，整个过程中，没有任何的数据存储，一切都是实时转发的。</p>
<p>这种设计方案，就导致了上面提到的那些问题。</p>
<p>例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。</p>
<p>如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。</p>
<p>所以，当你在使用 Pub/Sub 时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p>
<p>这也是前面讲例子时，我们让消费者先订阅队列，之后才让生产者发布消息的原因。</p>
<p>另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。</p>
<p>也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。</p>
<p>最后，我们来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？</p>
<p>当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。</p>
<p>如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。</p>
<p>但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致<strong>消费失败和消息丢失</strong>！</p>
<p>这是怎么回事？</p>
<p>还是回到 Pub/Sub 的实现细节上来说。</p>
<p>每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。</p>
<p>当生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。</p>
<p>之后，消费者不断地从缓冲区读取消息，处理消息。看到了么，整个过程中，没有任何的数据存储，一切都是实时转发的。</p>
<p>这种设计方案，就导致了上面提到的那些问题。</p>
<p>例如，如果一个消费者异常挂掉了，它再重新上线后，只能接收新的消息，在下线期间生产者发布的消息，因为找不到消费者，都会被丢弃掉。</p>
<p>如果所有消费者都下线了，那生产者发布的消息，因为找不到任何一个消费者，也会全部「丢弃」。</p>
<p>所以，当你在使用 Pub/Sub 时，一定要注意：<strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p>
<p>这也是前面讲例子时，我们让消费者先订阅队列，之后才让生产者发布消息的原因。</p>
<p>另外，因为 Pub/Sub 没有基于任何数据类型实现，所以它也不具备「数据持久化」的能力。</p>
<p>也就是说，Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失。</p>
<p>最后，我们来看 Pub/Sub 在处理「消息积压」时，为什么也会丢数据？</p>
<p>当消费者的速度，跟不上生产者时，就会导致数据积压的情况发生。</p>
<p>如果采用 List 当作队列，消息积压时，会导致这个链表很长，最直接的影响就是，Redis 内存会持续增长，直到消费者把所有数据都从链表中取出。</p>
<p>但 Pub/Sub 的处理方式却不一样，当消息积压时，有可能会导致<strong>消费失败和消息丢失</strong>！</p>
<p>这是怎么回事？</p>
<p>还是回到 Pub/Sub 的实现细节上来说。</p>
<p>每个消费者订阅一个队列时，Redis 都会在 Server 上给这个消费者在分配一个「缓冲区」，这个缓冲区其实就是一块内存。</p>
<p>当生产者发布消息时，Redis 先把消息写到对应消费者的缓冲区中。</p>
<p>之后，消费者不断地从缓冲区读取消息，处理消息。</p>
<p><img src="https://blob.hixforever.com/20210908133547.png" alt=""></p>
<p>但是，问题就出在这个缓冲区上。</p>
<p>因为这个缓冲区其实是有「上限」的（可配置），如果消费者拉取消息很慢，就会造成生产者发布到缓冲区的消息开始积压，缓冲区内存持续增长。</p>
<p>如果超过了缓冲区配置的上限，此时，Redis 就会「强制」把这个消费者踢下线。</p>
<p>这时消费者就会消费失败，也会丢失数据。</p>
<p>如果你有看过 Redis 的配置文件，可以看到这个缓冲区的默认配置：client-output-buffer-limit pubsub 32mb 8mb 60。</p>
<p>它的参数含义如下：</p>
<ul>
<li>32mb：缓冲区一旦超过 32MB，Redis 直接强制把消费者踢下线</li>
<li>8mb + 60：缓冲区超过 8MB，并且持续 60 秒，Redis 也会把消费者踢下线</li>
</ul>
<p>Pub/Sub 的这一点特点，是与 List 作队列差异比较大的。</p>
<p>从这里你应该可以看出，<strong>List 其实是属于「拉」模型，而 Pub/Sub 其实属于「推」模型</strong>。</p>
<p>List 中的数据可以一直积压在内存中，消费者什么时候来「拉」都可以。</p>
<p>但 Pub/Sub 是把消息先「推」到消费者在 Redis Server 上的缓冲区中，然后等消费者再来取。</p>
<p>当生产、消费速度不匹配时，就会导致缓冲区的内存开始膨胀，Redis 为了控制缓冲区的上限，所以就有了上面讲到的，强制把消费者踢下线的机制。</p>
<p>好了，现在我们总结一下 Pub/Sub 的优缺点：</p>
<ol>
<li>支持发布 / 订阅，支持多组生产者、消费者处理消息</li>
<li>消费者下线，数据会丢失</li>
<li>不支持数据持久化，Redis 宕机，数据也会丢失</li>
<li>消息堆积，缓冲区溢出，消费者会被强制踢下线，数据也会丢失</li>
</ol>
<p>有没有发现，除了第一个是优点之外，剩下的都是缺点。</p>
<p>所以，很多人看到 Pub/Sub 的特点后，觉得这个功能很「鸡肋」。</p>
<p>也正是以上原因，Pub/Sub 在实际的应用场景中用得并不多。</p>
<blockquote>
<p>目前只有哨兵集群和 Redis 实例通信时，采用了 Pub/Sub 的方案，因为哨兵正好符合即时通讯的业务场景。</p>
</blockquote>
<p>我们再来看一下，Pub/Sub 有没有解决，消息处理时异常宕机，无法再次消费的问题呢？</p>
<p>其实也不行，Pub/Sub 从缓冲区取走数据之后，数据就从 Redis 缓冲区删除了，消费者发生异常，自然也无法再次重新消费。</p>
<p>好，现在我们重新梳理一下，我们在使用消息队列时的需求。</p>
<p>当我们在使用一个消息队列时，希望它的功能如下：</p>
<ul>
<li>支持阻塞等待拉取消息</li>
<li>支持发布 / 订阅模式</li>
<li>消费失败，可重新消费，消息不丢失</li>
<li>实例宕机，消息不丢失，数据可持久化</li>
<li>消息可堆积</li>
</ul>
<p>Redis 除了 List 和 Pub/Sub 之外，还有符合这些要求的数据类型吗？</p>
<p>其实，Redis 的作者也看到了以上这些问题，也一直在朝着这些方向努力着。</p>
<p>Redis 作者在开发 Redis 期间，还另外开发了一个开源项目 disque。</p>
<p>这个项目的定位，就是一个基于内存的分布式消息队列中间件。</p>
<p>但由于种种原因，这个项目一直不温不火。</p>
<p>终于，在 Redis 5.0 版本，作者把 disque 功能移植到了 Redis 中，并给它定义了一个新的数据类型：<strong>Streams</strong>。</p>
<p>下面我们就来看看，它能符合上面提到的这些要求吗？</p>
<h3 id="四、基于-Streams-的消息队列解决方案"><a href="#四、基于-Streams-的消息队列解决方案" class="headerlink" title="四、基于 Streams 的消息队列解决方案"></a>四、基于 Streams 的消息队列解决方案</h3><p>Streams 是 Redis 专门为消息队列设计的数据类型，我们来看 Stream 是如何解决上面这些问题的。</p>
<p>我们依旧从简单到复杂，依次来看 Stream 在做消息队列时，是如何处理的？</p>
<h4 id="1-Streams-是如何实现消息队列需求的"><a href="#1-Streams-是如何实现消息队列需求的" class="headerlink" title="1. Streams 是如何实现消息队列需求的"></a>1. Streams 是如何实现消息队列需求的</h4><p>首先，Stream 通过 XADD 和 XREAD 完成最简单的生产、消费模型：</p>
<p><img src="https://blob.hixforever.com/20210908134259.png" alt=""></p>
<p>下面我们来看，针对前面提到的消息队列要求，Stream 都是如何解决的？</p>
<ol>
<li><strong>Streams 通过 XADD 和 XREAD 完成最简单的生产、消费模型。</strong></li>
<li><strong>Streams 通过BLOCK 参数支持「阻塞式」拉取消息</strong></li>
<li><strong>Stream 通过XGROUP和XREADGROUP支持发布 / 订阅模式</strong></li>
<li><strong>Stream 通过XACK标记消息为「处理完成」</strong></li>
<li><strong>Stream 数据会写入到 RDB 和 AOF 做持久化</strong></li>
<li><strong>Stream 处理消息堆积方式，采用丢弃消息的方式</strong><ul>
<li>在发布消息时，可以指定队列的最大长度，防止队列积压导致内存爆炸。当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。<code>XADD mystream MAXLEN 10000 * repo 1</code></li>
</ul>
</li>
<li></li>
</ol>
<h4 id="2-Streams与专业的消息队列对比"><a href="#2-Streams与专业的消息队列对比" class="headerlink" title="2. Streams与专业的消息队列对比"></a>2. Streams与专业的消息队列对比</h4><p>其实，一个专业的消息队列，必须要做到两大块：</p>
<ol>
<li>消息不丢</li>
<li>消息可堆积</li>
</ol>
<p>前面我们讨论的重点，很大篇幅围绕的是第一点展开的。</p>
<p>这里我们换个角度，从一个消息队列的「使用模型」来分析一下，怎么做，才能保证数据不丢？</p>
<p>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>。</p>
<p><img src="https://blob.hixforever.com/20210908140607.png" alt=""></p>
<p>消息是否会发生丢失，其重点也就在于以下 3 个环节：</p>
<ol>
<li>生产者会不会丢消息？</li>
<li>消费者会不会丢消息？</li>
<li>队列中间件会不会丢消息？</li>
</ol>
<p><strong>1) 生产者会不会丢消息？</strong></p>
<p>当生产者在发布消息时，可能发生以下异常情况：</p>
<ol>
<li>消息没发出去：网络故障或其它问题导致发布失败，中间件直接返回失败</li>
<li>不确定是否发布成功：网络问题导致发布超时，可能数据已发送成功，但读取响应结果超时了</li>
</ol>
<p>如果是情况 1，消息根本没发出去，那么重新发一次就好了。</p>
<p>如果是情况 2，生产者没办法知道消息到底有没有发成功？所以，为了避免消息丢失，它也只能继续重试，直到发布成功为止。</p>
<blockquote>
<p>生产者一般会设定一个最大重试次数，超过上限依旧失败，需要记录日志报警处理。</p>
</blockquote>
<p>也就是说，生产者为了避免消息丢失，只能采用失败重试的方式来处理。</p>
<p>但发现没有？这也意味着消息可能会重复发送。</p>
<p>是的，在使用消息队列时，要保证消息不丢，宁可重发，也不能丢弃。</p>
<p>那消费者这边，就需要多做一些逻辑了。</p>
<p>对于敏感业务，当消费者收到重复数据数据时，要设计幂等逻辑，保证业务的正确性。</p>
<p>从这个角度来看，生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。</p>
<p>所以，无论是 Redis 还是专业的队列中间件，生产者在这一点上都是可以保证消息不丢的。</p>
<p><strong>2) 消费者会不会丢消息？</strong></p>
<p>这种情况就是我们前面提到的，消费者拿到消息后，还没处理完成，就异常宕机了，那消费者还能否重新消费失败的消息？</p>
<p>要解决这个问题，消费者在处理完消息后，必须「告知」队列中间件，队列中间件才会把标记已处理，否则仍旧把这些数据发给消费者。</p>
<p>这种方案需要消费者和中间件互相配合，才能保证消费者这一侧的消息不丢。</p>
<p>无论是 Redis 的 Stream，还是专业的队列中间件，例如 RabbitMQ、Kafka，其实都是这么做的。</p>
<p>所以，从这个角度来看，Redis 也是合格的。</p>
<p><strong>3) 队列中间件会不会丢消息？</strong></p>
<p>前面 2 个问题都比较好处理，只要客户端和服务端配合好，就能保证生产端、消费端都不丢消息。</p>
<p>但是，如果队列中间件本身就不可靠呢？</p>
<p>毕竟生产者和消费这都依赖它，如果它不可靠，那么生产者和消费者无论怎么做，都无法保证数据不丢。</p>
<p>在这个方面，Redis 其实没有达到要求。</p>
<p>Redis 在以下 2 个场景下，都会导致数据丢失。</p>
<ol>
<li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li>
<li>主从复制也是异步的，主从切换时，也存在丢失数据的可能（从库还未同步完成主库发来的数据，就被提成主库）</li>
</ol>
<p>基于以上原因我们可以看到，<strong>Redis 本身的无法保证严格的数据完整性</strong>。</p>
<p>所以，如果把 Redis 当做消息队列，在这方面是有可能导致数据丢失的。</p>
<p>再来看那些专业的消息队列中间件是如何解决这个问题的？</p>
<p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时，一般是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，以此保证消息的完整性。这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p>
<p>也正因为如此，RabbitMQ、Kafka在设计时也更复杂。毕竟，它们是专门针对队列场景设计的。</p>
<p>但 Redis 的定位则不同，它的定位更多是当作缓存来用，它们两者在这个方面肯定是存在差异的。</p>
<p>最后，我们来看消息积压怎么办？</p>
<p><strong>4) 消息积压怎么办？</strong></p>
<p>因为 Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</p>
<p>所以，Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p>
<p>但 Kafka、RabbitMQ 这类消息队列就不一样了，它们的数据都会存储在磁盘上，磁盘的成本要比内存小得多，当消息积压时，无非就是多占用一些磁盘空间，相比于内存，在面对积压时也会更加「坦然」。</p>
<p>综上，我们可以看到，把 Redis 当作队列来使用时，始终面临的 2 个问题：</p>
<ol>
<li>Redis 本身可能会丢数据</li>
<li>面对消息积压，Redis 内存资源紧张</li>
</ol>
<p>到这里，Redis 是否可以用作队列，我想这个答案你应该会比较清晰了。</p>
<p>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</p>
<p>而且，Redis 相比于 Kafka、RabbitMQ，部署和运维也更加轻量。</p>
<p>如果你的业务场景对于数据丢失非常敏感，而且写入量非常大，消息积压时会占用很多的机器资源，那么我建议你使用专业的消息队列中间件。</p>
<h4 id="3-Streams操作命令简介"><a href="#3-Streams操作命令简介" class="headerlink" title="3. Streams操作命令简介"></a>3. Streams操作命令简介</h4><p>Streams提供了丰富的消息队列操作命令。</p>
<ul>
<li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID。</li>
<li>XREAD：用于读取消息，可以按 ID 读取数据。</li>
<li>XGROUP CREATE：创建消费组。</li>
<li>XREADGROUP：按消费组形式读取消息。</li>
<li>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</li>
</ul>
<h5 id="1-XADD"><a href="#1-XADD" class="headerlink" title="1. XADD"></a>1. XADD</h5><p>语法格式：</p>
<blockquote>
<p><code>XADD key ID field value [field value ...]</code></p>
<ul>
<li>key：队列名称，如果不存在就创建</li>
<li>ID：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。</li>
<li>field value [field value …]，key-value类型数据</li>
</ul>
</blockquote>
<p>XADD 命令可以往消息队列中插入新消息，消息的格式是键 - 值对形式。对于插入的每一条消息，Streams 可以自动为其生成一个全局唯一的 ID。我们执行下面的命令，就可以往名称为 mqstream 的消息队列中插入一条消息。</p>
<p>下面命令组成如下：</p>
<ul>
<li>消息的键是 repo</li>
<li>值是 5。</li>
<li>消息队列名称后面的*，表示让 Redis 为插入的数据自动生成一个全局唯一的 ID。可以看到，消息的全局唯一 ID 由两部分组成<code>1631010568190-0</code>。<ul>
<li>1631010568190：数据插入时，以毫秒为单位计算的当前服务器时间</li>
<li>0：表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *表示让Redis自动生成消息ID</span></span><br><span class="line"><span class="comment"># XADD key ID field value [field value ...]</span></span><br><span class="line">127.0.0.1:6379&gt; XADD mqstream * repo 5</span><br><span class="line"><span class="string">"1631010546467-0"</span></span><br><span class="line">127.0.0.1:6379&gt; XADD mqstream * repo 6</span><br><span class="line"><span class="string">"1631010568190-0"</span></span><br></pre></td></tr></table></figure>
<h5 id="2-XREAD"><a href="#2-XREAD" class="headerlink" title="2. XREAD"></a>2. XREAD</h5><p>语法格式：</p>
<blockquote>
<p><code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code></p>
<ul>
<li>[COUNT count]：用来获取消息的数量</li>
<li>[BLOCK milliseconds]：用来设置阻塞模式和阻塞超时时间，默认为非阻塞</li>
<li>id [id …]：用来设置读取的起始 ID，相当于 where id &gt; $id，阻塞模式中可以使用 $ 来获取最新的消息 ID，非阻塞模式下无意义。</li>
<li>key：队列名</li>
</ul>
</blockquote>
<p>当消费者需要读取消息时，可以直接使用 XREAD 命令从消息队列中读取。</p>
<p>XREAD 在读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取。</p>
<p>例如，我们可以执行下面的命令，从 ID 号为 1631010542237-0 的消息开始，读取后续的所有消息（示例中一共 3 条）。参数说明如下：</p>
<ul>
<li>block：当消息队列中没有消息时，一旦设置了 BLOCK 配置项，XREAD 就会阻塞，阻塞的时长可以在 BLOCK 配置项进行设置。<strong>BLOCK 0 表示阻塞等待，不设置超时时间</strong>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 0 STREAMS mqstream 1631010542237-0</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010544817-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"4"</span></span><br><span class="line">      2) 1) <span class="string">"1631010546467-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"5"</span></span><br><span class="line">      3) 1) <span class="string">"1631010568190-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"6"</span></span><br></pre></td></tr></table></figure>
<p>看下面命令，其中，命令最后的“$”符号表示读取最新的消息，同时，我们设置了 block 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。下面命令中的 XREAD 执行后，消息队列 mqstream 中一直没有消息，所以，XREAD 在 10 秒后返回空值（nil）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; XREAD BLOCK 10000 STREAMS mqstream $</span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure>
<h5 id="3-XGROUP-CREATE"><a href="#3-XGROUP-CREATE" class="headerlink" title="3. XGROUP CREATE"></a>3. XGROUP CREATE</h5><p>语法格式：</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XGROUP [CREATE key groupname id-or-$] [SETID key groupname id-or-$] [DESTROY key groupname] [CREATECONSUMER key groupname consumername] [DELCONSUMER key groupname consumername]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ul>
<li><code>[CREATE key groupname id-or-$]</code>：在指定的 key 中创建分组，并且指定分组读取消息的起点，如果指定了0，分组将可以读取指定 key 的所有历史消息，如果指定了 $，分组将可以读取指定 key 的新消息，将不能读取历史消息。也可以指定任意的开始 ID。</li>
<li><code>[SETID key groupname id-or-$]</code>：重新给已存在的分组设置消息读取的起点。例如将起点设置为 0就可以重新读取所有的历史消息</li>
<li><code>[DESTROY key groupname]</code>：销毁指定 key 中的一个分组</li>
<li><code>[CREATECONSUMER key groupname consumername]</code>：在指定的 key 和指定的分组中创建一个消费者。当某个命令提及了新的消费者名称时，也会自动创建新的消费者。</li>
<li><code>[DELCONSUMER key groupname consumername]</code>：在指定的 key 和指定的分组中销毁一个消费者。</li>
<li><code>$</code>：表示从尾部开始消费，只接受新消息，当前 Stream 消息会全部忽略。</li>
</ul>
</blockquote>
<p>执行下面的命令，</p>
<ol>
<li><code>XGROUP create mqstream group1 0</code>：创建一个名为 group1 的消费组，这个消费组消费的消息队列是 mqstream。</li>
<li><code>XREADGROUP group group1 consumer1 streams mqstream &gt;</code>：让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，<strong>命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取</strong>。因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以，consumer1 就得到 mqstream 消息队列中的所有消息了（一共 6 条）。</li>
<li><code>XREADGROUP group group1 consumer1 streams mqstream &gt;</code>：再次执行上述2命令查看返回效果</li>
<li><code>XREADGROUP group group1 consumer2 streams mqstream 0</code>：需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。比如说，我们执行完刚才的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完了.</li>
<li><code>XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</code>：使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mqstream group1 0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010537963-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"1"</span></span><br><span class="line">      2) 1) <span class="string">"1631010540381-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"2"</span></span><br><span class="line">      3) 1) <span class="string">"1631010542237-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"3"</span></span><br><span class="line">      4) 1) <span class="string">"1631010544817-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"4"</span></span><br><span class="line">      5) 1) <span class="string">"1631010546467-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"5"</span></span><br><span class="line">      6) 1) <span class="string">"1631010568190-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"6"</span></span><br><span class="line"><span class="comment"># 3            </span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer2 streams mqstream 0</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) (empty array)    </span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mqstream group2 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010537963-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"1"</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010540381-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"2"</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010542237-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"3"</span></span><br></pre></td></tr></table></figure>
<h5 id="4-XREADGROUP-GROUP"><a href="#4-XREADGROUP-GROUP" class="headerlink" title="4. XREADGROUP GROUP"></a>4. XREADGROUP GROUP</h5><p>使用 XREADGROUP GROUP 读取消费组中的消息</p>
<p>语法格式：</p>
<blockquote>
<p><code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</code></p>
<ul>
<li>GROUP：固定</li>
<li>group：消费组名</li>
<li>consumer：消费者名</li>
<li>[COUNT count]：每次获取消息的数量</li>
<li>[BLOCK milliseconds]：阻塞模式和超时时间</li>
<li>[NOACK]：不需要确认消息，适用于不怎么重要的可以丢失的消息</li>
<li>STREAMS：固定</li>
<li>key [key …]：指定的队列名</li>
<li>ID [ID …]：指定的消息 ID，&gt; 指定读取所有未消费的消息，其他值指定被挂起的消息</li>
</ul>
</blockquote>
<p>执行如下命令：</p>
<ol>
<li><code>XREADGROUP group group1 consumer1 streams mqstream &gt;</code>：让 group1 消费组里的消费者 consumer1 从 mqstream 中读取所有消息，其中，<strong>命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取</strong>。因为在 consumer1 读取消息前，group1 中没有其他消费者读取过消息，所以，consumer1 就得到 mqstream 消息队列中的所有消息了（一共 6 条）。</li>
<li><code>XREADGROUP group group1 consumer1 streams mqstream &gt;</code>：再次执行上述2命令查看返回效果</li>
<li><code>XREADGROUP group group1 consumer2 streams mqstream 0</code>：需要注意的是，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。比如说，我们执行完刚才的 XREADGROUP 命令后，再执行下面的命令，让 group1 内的 consumer2 读取消息时，consumer2 读到的就是空值，因为消息已经被 consumer1 读取完了.</li>
<li><code>XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</code>：使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010537963-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"1"</span></span><br><span class="line">      2) 1) <span class="string">"1631010540381-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"2"</span></span><br><span class="line">      3) 1) <span class="string">"1631010542237-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"3"</span></span><br><span class="line">      4) 1) <span class="string">"1631010544817-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"4"</span></span><br><span class="line">      5) 1) <span class="string">"1631010546467-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"5"</span></span><br><span class="line">      6) 1) <span class="string">"1631010568190-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"6"</span></span><br><span class="line"><span class="comment"># 2            </span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer1 streams mqstream &gt;</span><br><span class="line">(nil)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group1 consumer2 streams mqstream 0</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) (empty array)    </span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">127.0.0.1:6379&gt; XGROUP create mqstream group2 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer1 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010537963-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"1"</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer2 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010540381-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"2"</span></span><br><span class="line">127.0.0.1:6379&gt; XREADGROUP group group2 consumer3 count 1 streams mqstream &gt;</span><br><span class="line">1) 1) <span class="string">"mqstream"</span></span><br><span class="line">   2) 1) 1) <span class="string">"1631010542237-0"</span></span><br><span class="line">         2) 1) <span class="string">"repo"</span></span><br><span class="line">            2) <span class="string">"3"</span></span><br></pre></td></tr></table></figure>
<h5 id="5-XPENDING和XACK"><a href="#5-XPENDING和XACK" class="headerlink" title="5. XPENDING和XACK"></a>5. XPENDING和XACK</h5><p>语法格式：</p>
<blockquote>
<p><code>XPENDING key group [start end count] [consumer]</code></p>
<ul>
<li>key，指定的 key</li>
<li>group，指定的分组</li>
<li>[start end count]，起始 ID 和结束 ID 还有数量</li>
<li>consumer，消费者名字</li>
</ul>
</blockquote>
<p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p>
<p>执行如下命令：</p>
<ol>
<li>查看 group2 中各个消费者已读取、但尚未确认的消息个数。其中，XPENDING 返回结果的第二、三行分别表示 group2 中所有消费者读取的消息最小 ID 和最大 ID。</li>
<li>查看某个消费者具体读取了哪些数据</li>
<li>通过2步骤可以看到，consumer2 已读取的消息的 ID 是 1599274912765-0。一旦消息 1599274912765-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除。当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">127.0.0.1:6379&gt; XPENDING mqstream group2</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">"1631010537963-0"</span></span><br><span class="line">3) <span class="string">"1631010542237-0"</span></span><br><span class="line">4) 1) 1) <span class="string">"consumer1"</span></span><br><span class="line">      2) <span class="string">"1"</span></span><br><span class="line">   2) 1) <span class="string">"consumer2"</span></span><br><span class="line">      2) <span class="string">"1"</span></span><br><span class="line">   3) 1) <span class="string">"consumer3"</span></span><br><span class="line">      2) <span class="string">"1"</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">127.0.0.1:6379&gt; XPENDING mqstream group2 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">"1631010540381-0"</span></span><br><span class="line">   2) <span class="string">"consumer2"</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 1820141</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">127.0.0.1:6379&gt; XACK mqstream group2 1631010540381-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; XPENDING mqstream group2 - + 10 consumer2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>前面介绍了 List、Pub/Sub、Stream 在做队列的使用方式</p>
<p>之后又把 Redis 和专业的消息队列中间件做对比，发现 Redis 的不足之处。</p>
<p>最后，我们得出 Redis 做队列的合适场景。</p>
<p>这里我也列了一个表格，总结了它们各自的优缺点。</p>
<p><img src="https://blob.hixforever.com/20210908141139.png" alt=""></p>
<h3 id="六、后记"><a href="#六、后记" class="headerlink" title="六、后记"></a>六、后记</h3><p>最后，再聊一聊关于「<strong>技术方案选型</strong>」的问题。</p>
<p>我们在分析 Redis 细节时，一直在提出问题，然后寻找更好的解决方案，在文章最后，又聊到一个专业的消息队列应该怎么做。</p>
<p>其实，我们在讨论技术选型时，就是一个关于如何取舍的问题。</p>
<p>而这里我想传达给你的信息是，<strong>在面对技术选型时，不要不经过思考就觉得哪个方案好，哪个方案不好</strong>。</p>
<p>你需要根据具体场景具体分析，这里我把这个分析过程分为 2 个层面：</p>
<ol>
<li>业务功能角度</li>
<li>技术资源角度</li>
</ol>
<p>这篇文章所讲到的内容，都是以业务功能角度出发做决策的。</p>
<p>但这里的第二点，从技术资源角度出发，其实也很重要。</p>
<p>技术资源的角度是说，<strong>你所处的公司环境、技术资源能否匹配这些技术方案</strong>。</p>
<p>这个怎么解释呢？</p>
<p>简单来讲，就是你所在的公司、团队，是否有匹配的资源能 hold 住这些技术方案。</p>
<p>我们都知道 Kafka、RabbitMQ 是非常专业的消息中间件，但它们的部署和运维，相比于 Redis 来说，也会更复杂一些。</p>
<p>如果你在一个大公司，公司本身就有优秀的运维团队，那么使用这些中间件肯定没问题，因为有足够优秀的人能 hold 住这些中间件，公司也会投入人力和时间在这个方向上。</p>
<p>但如果你是在一个初创公司，业务正处在快速发展期，暂时没有能 hold 住这些中间件的团队和人，如果贸然使用这些组件，当发生故障时，排查问题也会变得很困难，甚至会阻碍业务的发展。</p>
<p>而这种情形下，如果公司的技术人员对于 Redis 都很熟，综合评估来看，Redis 也基本可以满足业务 90% 的需求，那当下选择 Redis 未必不是一个好的决策。</p>
<p>所以，<strong>做技术选型不只是技术问题，还与人、团队、管理、组织结构有关</strong>。</p>
<p>也正是因为这些原因，当你在和别人讨论技术选型问题时，你会发现每个公司的做法都不相同。</p>
<p>毕竟每个公司所处的环境和文化不一样，做出的决策当然就会各有差异。</p>
<p>如果你不了解这其中的逻辑，那在做技术选型时，只会趋于表面现象，无法深入到问题根源。</p>
<p>而一旦你理解了这个逻辑，那么你在看待这个问题时，不仅对于技术会有更加深刻认识，对技术资源和人的把握，也会更加清晰。</p>
<p>希望你以后在做技术选型时，能够把这些因素也考虑在内，这对你的技术成长之路也是非常有帮助的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/02/docker-nginx-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/02/docker-nginx-install/" itemprop="url">Docker 部署安装Nginx</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-02T09:00:36+08:00">
                2021-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Docker-部署安装Nginx"><a href="#Docker-部署安装Nginx" class="headerlink" title="Docker 部署安装Nginx"></a>Docker 部署安装Nginx</h3><h4 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/30/markdown-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/30/markdown-tips/" itemprop="url">MarkDown日常使用Tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-30T19:09:14+08:00">
                2021-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MarkDown/" itemprop="url" rel="index">
                    <span itemprop="name">MarkDown</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="MarkDown日常使用Tips"><a href="#MarkDown日常使用Tips" class="headerlink" title="MarkDown日常使用Tips"></a>MarkDown日常使用Tips</h3><h4 id="一、MarkDown表格中使用竖线"><a href="#一、MarkDown表格中使用竖线" class="headerlink" title="一、MarkDown表格中使用竖线"></a>一、MarkDown表格中使用竖线</h4><p>在表格中输入｜方法：使用<code>&amp;#124;</code>替换</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/30/docker-docker-cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/30/docker-docker-cmd/" itemprop="url">Docker相关基础命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-30T18:21:07+08:00">
                2021-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Docker相关基础命令"><a href="#Docker相关基础命令" class="headerlink" title="Docker相关基础命令"></a>Docker相关基础命令</h3><h4 id="一、镜像相关命令"><a href="#一、镜像相关命令" class="headerlink" title="一、镜像相关命令"></a>一、镜像相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docker pull</code></td>
<td>拉取镜像</td>
</tr>
<tr>
<td><code>docker images</code></td>
<td>列出本地所有镜像</td>
</tr>
<tr>
<td><code>docker image ls busybox</code></td>
<td>查询指定镜像</td>
</tr>
<tr>
<td><code>docker tag busybox:latest newbusybox:latest</code></td>
<td>将镜像重命名</td>
</tr>
<tr>
<td><code>docker tag busybox lagoudocker/busybox</code></td>
<td>重命名</td>
</tr>
<tr>
<td><code>docker rmi busybox</code></td>
<td>删除镜像</td>
</tr>
<tr>
<td><code>docker run --rm --name=busybox -it busybox sh</code></td>
<td>创建一个名为busybox的容器并进入busybox容器</td>
</tr>
<tr>
<td><code>touch hello.txt &amp;&amp; echo &quot;I love Docker&quot; &gt; hello.txt</code></td>
<td>创建一个文件并写入内容</td>
</tr>
<tr>
<td><code>docker commit busybox busybox:hello</code></td>
<td>提交镜像</td>
</tr>
<tr>
<td><code>docker build -t mybusybox</code></td>
<td>在Dockerfile所在目录构建一个镜像</td>
</tr>
</tbody>
</table>
<h4 id="二、仓库相关"><a href="#二、仓库相关" class="headerlink" title="二、仓库相关"></a>二、仓库相关</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docker push lagoudocker/busybox</code></td>
<td>推送镜像到自己创建的仓库</td>
</tr>
<tr>
<td><code>docker run -d -p 5000:5000 --name registry registry:2.7</code></td>
<td>运行镜像registry:2.7</td>
</tr>
<tr>
<td><code>docker rmi busybox localhost:5000/busybox</code></td>
<td>删除本地busybox和local~镜像</td>
</tr>
<tr>
<td><code>docker pull localhost:5000/busybox</code></td>
<td>从本地镜像仓库拉取busybox镜像</td>
</tr>
</tbody>
</table>
<h4 id="三、容器相关"><a href="#三、容器相关" class="headerlink" title="三、容器相关"></a>三、容器相关</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docker start</code></td>
<td>基于已经创建好的容器直接启动</td>
</tr>
<tr>
<td><code>docker run</code></td>
<td>直接基于镜像新建一个容器并启动</td>
</tr>
<tr>
<td><code>docker create -it --name=busybox busybox</code></td>
<td>创建容器</td>
</tr>
<tr>
<td>docker ps -a &#124; grep busybox</td>
<td>查看所有容器，并通过grep过滤输出</td>
</tr>
<tr>
<td><code>docker start busybox</code></td>
<td>启动容器</td>
</tr>
<tr>
<td><code>docker ps</code></td>
<td>查看当前运行的容器</td>
</tr>
<tr>
<td><code>docker run -it --name=busybox busybox</code></td>
<td>进入容器</td>
</tr>
<tr>
<td><code>docker stop busybox</code></td>
<td>停止容器</td>
</tr>
<tr>
<td><code>docker ps -a</code></td>
<td>查看全部容器信息</td>
</tr>
<tr>
<td><code>dockers restart busybox</code></td>
<td>重启容器</td>
</tr>
<tr>
<td><code>docker attach busybox</code></td>
<td>进入容器（容器已经启动，退出后容器停止）</td>
</tr>
<tr>
<td><code>docker exec -it busybox /bin/bash</code></td>
<td>进入容器（容器已经启动，退出后容器不停止）</td>
</tr>
<tr>
<td><code>docker rm busybox</code></td>
<td>删除一个停止状态的容器</td>
</tr>
<tr>
<td><code>docker rm -f busybox</code></td>
<td>删除正在运行的容器</td>
</tr>
<tr>
<td><code>docker export CONTAINER</code></td>
<td>导出一个容器到文件</td>
</tr>
<tr>
<td><code>docker export busybox &gt; busybox.tar</code></td>
<td>执行导出命令</td>
</tr>
<tr>
<td><code>docker import busybox.tar busybox:test</code></td>
<td>导入上一步导出的容器</td>
</tr>
<tr>
<td><code>docker run -it busybox:test sh</code></td>
<td>启动并进入容器</td>
</tr>
<tr>
<td><code>docker run -it --cpus=1 -m=2048m --pids-limit=1000 busybox /bin/bash</code></td>
<td>启动一个1核2G的容器，并且限制在容器内最多只能创建1000个PID</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="四、卷的相关命令"><a href="#四、卷的相关命令" class="headerlink" title="四、卷的相关命令"></a>四、卷的相关命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>docker volume create myvolume</code></td>
<td>创建数据卷</td>
</tr>
<tr>
<td><code>docker run -d --name=nginx-volume -v /usr/share/nginx/html nginx</code></td>
<td>在Docker启动时使用-v的方式指定容器内需要被持久化的路径</td>
</tr>
<tr>
<td><code>docker volume ls</code></td>
<td>查看主机上的卷</td>
</tr>
<tr>
<td><code>docker volume inspect myvolume</code></td>
<td>查看myvolume的详细信息</td>
</tr>
<tr>
<td><code>docker run -d --name=nginx --mount source=myvolume, target=/usr/share/nginx/html nginx</code></td>
<td>使用上一步创建的卷来启动一个nginx容器，并将/usr/share/nginx/html目录与卷关联</td>
</tr>
<tr>
<td><code>docker volume rm myvolume</code></td>
<td>删除数据卷。注意：正在被使用中的数据卷无法删除，需要先删除所有关联的容器</td>
</tr>
<tr>
<td><code>docker run --mount source=log-vol,target=/tmp/log --name=log-producer -it busybox</code></td>
<td>启动一个生产日志的容器(producer窗口来表示)</td>
</tr>
<tr>
<td><code>docker run -it --name consumer --volume-from log-producer busybox</code></td>
<td>启动消费者容器</td>
</tr>
</tbody>
</table>
<h4 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h4><p>抽空过来补上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/27/docker--docker-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/27/docker--docker-install/" itemprop="url">Docker 环境安装及问题处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-27T15:22:30+08:00">
                2021-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Docker-环境安装及问题处理"><a href="#Docker-环境安装及问题处理" class="headerlink" title="Docker 环境安装及问题处理"></a>Docker 环境安装及问题处理</h3><h4 id="一、Dokcer安装"><a href="#一、Dokcer安装" class="headerlink" title="一、Dokcer安装"></a>一、Dokcer安装</h4><p>我们要安装一个目前最主流的容器技术的实现 Docker。假设我们的操作系统是 CentOS，你可以参考<a href="https://docs.docker.com/install/linux/docker-ce/centos/这个官方文档，进行安装。" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/这个官方文档，进行安装。</a></p>
<ol>
<li><p>第一步，删除原有版本的 Docker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>第二步，存储库安装，设置存储库</p>
<p>安装<code>yum-utils</code>包（提供<code>yum-config-manager</code> 实用程序）并设置<strong>稳定</strong>存储库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>第三步，安装 Docker 引擎。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>第四部，启动 Docker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>第五步，设置Docker开机自启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、关于Docker命令对于普通用户的权限问题解决方案"><a href="#二、关于Docker命令对于普通用户的权限问题解决方案" class="headerlink" title="二、关于Docker命令对于普通用户的权限问题解决方案"></a>二、关于Docker命令对于普通用户的权限问题解决方案</h4><p>安装按Docker后，使用普通用户执行<code>docker ps</code>命令会出现如下错误。这是由于普通用户不具有使用docker权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get &quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.24/containers/json&quot;: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure>
<p><img src="https://blob.hixforever.com/image-20210827153751349.png" alt="image-20210827153751349"></p>
<p>解决方案：</p>
<ol>
<li><p>添加docker用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>把用户加入docker用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -a sse docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否添加成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group | grep <span class="string">'^docker'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试docker命令是否可以使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/22/docker-harbor-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/22/docker-harbor-install/" itemprop="url">Harbor 私有仓库构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-22T19:29:07+08:00">
                2021-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Harbor-私有仓库构建"><a href="#Harbor-私有仓库构建" class="headerlink" title="Harbor 私有仓库构建"></a>Harbor 私有仓库构建</h3><h4 id="一、Harbor-介绍"><a href="#一、Harbor-介绍" class="headerlink" title="一、Harbor 介绍"></a>一、Harbor 介绍</h4><p>Docker容器应用的开发和运行离不开可靠的镜像管理，虽然Docker官方也提供了公共的镜像仓库，但是从安全和效率等方面考虑，部署私有环境内的Registry也是非常必要的。Harbor是由VMware公司开源的企业级的Docker Registry管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、自我注册、镜像复制和中文支持等功能</p>
<h4 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h4><h5 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1.硬件"></a>1.硬件</h5><table>
<thead>
<tr>
<th>资源</th>
<th>最低</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>中央处理器</td>
<td>2核</td>
<td>4核</td>
</tr>
<tr>
<td>内存</td>
<td>4GB</td>
<td>8GB</td>
</tr>
<tr>
<td>粗盘</td>
<td>40GB</td>
<td>160GB</td>
</tr>
</tbody>
</table>
<h5 id="2-软件"><a href="#2-软件" class="headerlink" title="2.软件"></a>2.软件</h5><table>
<thead>
<tr>
<th>关键</th>
<th>版本</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker engine</td>
<td>17.06.0-ce+以上</td>
<td><a href="https://docs.docker.com/engine/install/" target="_blank" rel="noopener">https://docs.docker.com/engine/install/</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>1.18.0以上</td>
<td><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">https://docs.docker.com/compose/install/</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>最新的优先</td>
<td>用于为Harbor生成证书和密钥</td>
</tr>
</tbody>
</table>
<h5 id="3-网络端口"><a href="#3-网络端口" class="headerlink" title="3.网络端口"></a>3.网络端口</h5><p>Harbor要求在目标主机上打开以下端口</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor和核心API接受此端口上的请求。可以在配置文件中更改此端口</td>
</tr>
<tr>
<td>4443</td>
<td>HTTPS</td>
<td>连接到 Harbor 的 Docker Content Trust 服务。仅在启用 Notary 时才需要。您可以在配置文件中更改此端口。</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor和核心API接受此端口上的请求。可以在配置文件中更改此端口</td>
</tr>
</tbody>
</table>
<h4 id="三、下载Harbor安装程序"><a href="#三、下载Harbor安装程序" class="headerlink" title="三、下载Harbor安装程序"></a>三、下载Harbor安装程序</h4><h5 id="1-打开下载页面"><a href="#1-打开下载页面" class="headerlink" title="1.打开下载页面"></a>1.打开下载页面</h5><p><a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">https://github.com/goharbor/harbor/releases</a></p>
<h5 id="2-选择离线安装或者在线安装"><a href="#2-选择离线安装或者在线安装" class="headerlink" title="2.选择离线安装或者在线安装"></a>2.选择离线安装或者在线安装</h5><p><img src="https://blob.hixforever.com/image-20210822223328975.png" alt=""></p>
<h5 id="3-使用tar提取安装包"><a href="#3-使用tar提取安装包" class="headerlink" title="3.使用tar提取安装包"></a>3.使用tar提取安装包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash $ tar xzvf harbor-offline-installer-version.tgz</span><br></pre></td></tr></table></figure>
<h4 id="四、配置HTTPS访问Harbor"><a href="#四、配置HTTPS访问Harbor" class="headerlink" title="四、配置HTTPS访问Harbor"></a>四、配置HTTPS访问Harbor</h4><h5 id="1-准备HTTPS证书"><a href="#1-准备HTTPS证书" class="headerlink" title="1.准备HTTPS证书"></a>1.准备HTTPS证书</h5><p>yourdomain.com.crt</p>
<p>yourdomain.com.key</p>
<h5 id="2-向Harbor和Docker提供证书"><a href="#2-向Harbor和Docker提供证书" class="headerlink" title="2.向Harbor和Docker提供证书"></a>2.向Harbor和Docker提供证书</h5><ol>
<li><p>将服务器证书和密钥复制到 Harbor 主机上的 certficates 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp yourdomain.com.crt /data/cert/</span><br><span class="line">cp yourdomain.com.key /data/cert/</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换<code>yourdomain.com.crt</code>为<code>yourdomain.com.cert</code>，供 Docker 使用。<br>Docker 守护进程将<code>.crt</code>文件解释为 CA 证书，将<code>.cert</code>文件解释为客户端证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform PEM -<span class="keyword">in</span> yourdomain.com.crt -out yourdomain.com.cert</span><br></pre></td></tr></table></figure>
<p><img src="https://blob.hixforever.com/image-20210822225823851.png" alt=""></p>
</li>
<li><p>重启Docker引擎</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="3-配置Harbor-YML文件"><a href="#3-配置Harbor-YML文件" class="headerlink" title="3.配置Harbor YML文件"></a>3.配置Harbor YML文件</h5><ol>
<li><p>在harbor的安装目录下找到<code>harbor.yml.tmpl</code>并复制一份</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp harbor.yml.tmpl harbor.ymls</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>配置主机名</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The IP address or hostname to access admin UI and registry service.</span></span><br><span class="line"><span class="comment"># DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">yourdomain.com</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>配置HTTPS的证书</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line"><span class="attr">  certificate:</span> <span class="string">/var/lib/sse/keys/yourdomain.com.crt</span></span><br><span class="line"><span class="attr">  private_key:</span> <span class="string">/var/lib/sse/keys/yourdomain.com.key</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置镜像数据存放地址</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The default data volume</span></span><br><span class="line"><span class="attr">data_volume:</span> <span class="string">/var/lib/sse/data</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定管理员密码</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The initial password of Harbor admin</span></span><br><span class="line"><span class="comment"># It only works in first time to install harbor</span></span><br><span class="line"><span class="comment"># Remember Change the admin password from UI after launching Harbor.</span></span><br><span class="line"><span class="attr">harbor_admin_password:</span> <span class="string">Harbor12345</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="4-部署或重新配置Harbor"><a href="#4-部署或重新配置Harbor" class="headerlink" title="4.部署或重新配置Harbor"></a>4.部署或重新配置Harbor</h5><ol>
<li><p>运行<code>prepare</code>脚本以启用 HTTPS。</p>
<p>Harbor 使用一个<code>nginx</code>实例作为所有服务的反向代理。您可以使用<code>prepare</code>脚本进行配置<code>nginx</code>以使用 HTTPS。该<code>prepare</code>在Harbor的安装包，在同级别的<code>install.sh</code>脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prepare</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 Harbor 正在运行，请停止并删除现有实例。</p>
<p>您的镜像数据保留在文件系统中，因此不会丢失任何数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Harbor</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="五、测试访问"><a href="#五、测试访问" class="headerlink" title="五、测试访问"></a>五、测试访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://yourdomain.com</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/15/mysql-move-datadir/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Ch">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宁静的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/15/mysql-move-datadir/" itemprop="url">Linux下迁移Mysql数据目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-15T17:02:26+08:00">
                2020-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux下迁移Mysql数据目录"><a href="#Linux下迁移Mysql数据目录" class="headerlink" title="Linux下迁移Mysql数据目录"></a>Linux下迁移Mysql数据目录</h2><blockquote>
<p>最初架构设计，mysql的数据目录被放在系统盘里面，随着数据的不断增长，系统盘必须随着数据不断扩容，才能满足服务的正常运行。当系统盘扩容到1T的时候出现了瓶颈，系统盘最高支持扩容到1T。这使得不能不面临mysql数据目录迁移到数据盘问题。</p>
</blockquote>
<h3 id="一-迁移时需要考虑的事项"><a href="#一-迁移时需要考虑的事项" class="headerlink" title="一.迁移时需要考虑的事项"></a>一.迁移时需要考虑的事项</h3><ol>
<li>尽可能少的迁移改动，防止在数据迁移时出错</li>
<li>需要考虑到目前服务还在使用，所以迁移应该尽可能快的完成。</li>
<li>迁移尽量不影响多源复制，如果复制中断，修复起来比较麻烦，而且还影响微信端的正常使用。</li>
<li>系统盘不能缩容，需要考虑剩余的系统盘空间怎么办</li>
</ol>
<h3 id="二-迁移步骤"><a href="#二-迁移步骤" class="headerlink" title="二.迁移步骤"></a>二.迁移步骤</h3><ol>
<li><p>在中央业务库中暂停迁移学校的多源复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop slave for channel &quot;school47&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂停学校服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止mysql服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制原数据目录的数据到将要迁移的数据目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.进入挂载的数据盘目录</span></span><br><span class="line"><span class="meta">shell&gt;</span><span class="bash"> <span class="built_in">cd</span> /mnt/sse/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.将原数据目录下的文件复制到将要迁移的目录，注意这里cp要加 -a，需要保留原文件属性</span></span><br><span class="line"><span class="meta">shell&gt;</span><span class="bash"> cp -a -r /var/lib/mysql/ ./</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改/etc/my.cnf文件中的配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-log-bin</span><br><span class="line">datadir=/mnt/sse/mysql</span><br><span class="line">socket=/mnt/sse/mysql/mysql.sock</span><br><span class="line">[client]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不设置这句的话，登录数据库的时候会报：ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/lib/mysql/mysql.sock<span class="string">' (2)</span></span></span><br><span class="line">socket=/mnt/sse/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里一定需要使用start,不能用restart,否则会出现问题</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars1.githubusercontent.com/u/6983464?v=4&u=a5c0462250ccca7b22994fee0da78ec155f242a0&s=400"
                alt="Henry Ch" />
            
              <p class="site-author-name" itemprop="name">Henry Ch</p>
              <p class="site-description motion-element" itemprop="description">守住自己那颗宁静的心！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry Ch</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://henrysworld.github.io/">CH</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash;
Henry.Scorpio
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
